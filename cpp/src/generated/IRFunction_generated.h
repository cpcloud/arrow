// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_IRFUNCTION_ORG_APACHE_ARROW_IR_FLATBUF_H_
#define FLATBUFFERS_GENERATED_IRFUNCTION_ORG_APACHE_ARROW_IR_FLATBUF_H_

#include "flatbuffers/flatbuffers.h"

#include "Schema_generated.h"

namespace org {
namespace apache {
namespace arrow {
namespace ir {
namespace flatbuf {

struct FunctionId;
struct FunctionIdBuilder;

struct DirectOutputType;
struct DirectOutputTypeBuilder;

struct ComplexOutputType;
struct ComplexOutputTypeBuilder;

struct DirectArgument;
struct DirectArgumentBuilder;

struct WildcardArgument;
struct WildcardArgumentBuilder;

struct FunctionSignature;
struct FunctionSignatureBuilder;

enum class OutputDerivation : uint8_t {
  NONE = 0,
  DirectOutputType = 1,
  ComplexOutputType = 2,
  MIN = NONE,
  MAX = ComplexOutputType
};

inline const OutputDerivation (&EnumValuesOutputDerivation())[3] {
  static const OutputDerivation values[] = {
    OutputDerivation::NONE,
    OutputDerivation::DirectOutputType,
    OutputDerivation::ComplexOutputType
  };
  return values;
}

inline const char * const *EnumNamesOutputDerivation() {
  static const char * const names[4] = {
    "NONE",
    "DirectOutputType",
    "ComplexOutputType",
    nullptr
  };
  return names;
}

inline const char *EnumNameOutputDerivation(OutputDerivation e) {
  if (flatbuffers::IsOutRange(e, OutputDerivation::NONE, OutputDerivation::ComplexOutputType)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesOutputDerivation()[index];
}

template<typename T> struct OutputDerivationTraits {
  static const OutputDerivation enum_value = OutputDerivation::NONE;
};

template<> struct OutputDerivationTraits<org::apache::arrow::ir::flatbuf::DirectOutputType> {
  static const OutputDerivation enum_value = OutputDerivation::DirectOutputType;
};

template<> struct OutputDerivationTraits<org::apache::arrow::ir::flatbuf::ComplexOutputType> {
  static const OutputDerivation enum_value = OutputDerivation::ComplexOutputType;
};

bool VerifyOutputDerivation(flatbuffers::Verifier &verifier, const void *obj, OutputDerivation type);
bool VerifyOutputDerivationVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum class Argument : uint8_t {
  NONE = 0,
  WildcardArgument = 1,
  DirectArgument = 2,
  MIN = NONE,
  MAX = DirectArgument
};

inline const Argument (&EnumValuesArgument())[3] {
  static const Argument values[] = {
    Argument::NONE,
    Argument::WildcardArgument,
    Argument::DirectArgument
  };
  return values;
}

inline const char * const *EnumNamesArgument() {
  static const char * const names[4] = {
    "NONE",
    "WildcardArgument",
    "DirectArgument",
    nullptr
  };
  return names;
}

inline const char *EnumNameArgument(Argument e) {
  if (flatbuffers::IsOutRange(e, Argument::NONE, Argument::DirectArgument)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesArgument()[index];
}

template<typename T> struct ArgumentTraits {
  static const Argument enum_value = Argument::NONE;
};

template<> struct ArgumentTraits<org::apache::arrow::ir::flatbuf::WildcardArgument> {
  static const Argument enum_value = Argument::WildcardArgument;
};

template<> struct ArgumentTraits<org::apache::arrow::ir::flatbuf::DirectArgument> {
  static const Argument enum_value = Argument::DirectArgument;
};

bool VerifyArgument(flatbuffers::Verifier &verifier, const void *obj, Argument type);
bool VerifyArgumentVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct FunctionId FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FunctionIdBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_ORG = 6
  };
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  uint32_t org() const {
    return GetField<uint32_t>(VT_ORG, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID) &&
           VerifyField<uint32_t>(verifier, VT_ORG) &&
           verifier.EndTable();
  }
};

struct FunctionIdBuilder {
  typedef FunctionId Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(FunctionId::VT_ID, id, 0);
  }
  void add_org(uint32_t org) {
    fbb_.AddElement<uint32_t>(FunctionId::VT_ORG, org, 0);
  }
  explicit FunctionIdBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FunctionIdBuilder &operator=(const FunctionIdBuilder &);
  flatbuffers::Offset<FunctionId> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FunctionId>(end);
    return o;
  }
};

inline flatbuffers::Offset<FunctionId> CreateFunctionId(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    uint32_t org = 0) {
  FunctionIdBuilder builder_(_fbb);
  builder_.add_org(org);
  builder_.add_id(id);
  return builder_.Finish();
}

struct DirectOutputType FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DirectOutputTypeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE_TYPE = 4,
    VT_TYPE = 6
  };
  org::apache::arrow::flatbuf::Type type_type() const {
    return static_cast<org::apache::arrow::flatbuf::Type>(GetField<uint8_t>(VT_TYPE_TYPE, 0));
  }
  const void *type() const {
    return GetPointer<const void *>(VT_TYPE);
  }
  template<typename T> const T *type_as() const;
  const org::apache::arrow::flatbuf::Null *type_as_Null() const {
    return type_type() == org::apache::arrow::flatbuf::Type::Null ? static_cast<const org::apache::arrow::flatbuf::Null *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::Int *type_as_Int() const {
    return type_type() == org::apache::arrow::flatbuf::Type::Int ? static_cast<const org::apache::arrow::flatbuf::Int *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::FloatingPoint *type_as_FloatingPoint() const {
    return type_type() == org::apache::arrow::flatbuf::Type::FloatingPoint ? static_cast<const org::apache::arrow::flatbuf::FloatingPoint *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::Binary *type_as_Binary() const {
    return type_type() == org::apache::arrow::flatbuf::Type::Binary ? static_cast<const org::apache::arrow::flatbuf::Binary *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::Utf8 *type_as_Utf8() const {
    return type_type() == org::apache::arrow::flatbuf::Type::Utf8 ? static_cast<const org::apache::arrow::flatbuf::Utf8 *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::Bool *type_as_Bool() const {
    return type_type() == org::apache::arrow::flatbuf::Type::Bool ? static_cast<const org::apache::arrow::flatbuf::Bool *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::Decimal *type_as_Decimal() const {
    return type_type() == org::apache::arrow::flatbuf::Type::Decimal ? static_cast<const org::apache::arrow::flatbuf::Decimal *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::Date *type_as_Date() const {
    return type_type() == org::apache::arrow::flatbuf::Type::Date ? static_cast<const org::apache::arrow::flatbuf::Date *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::Time *type_as_Time() const {
    return type_type() == org::apache::arrow::flatbuf::Type::Time ? static_cast<const org::apache::arrow::flatbuf::Time *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::Timestamp *type_as_Timestamp() const {
    return type_type() == org::apache::arrow::flatbuf::Type::Timestamp ? static_cast<const org::apache::arrow::flatbuf::Timestamp *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::Interval *type_as_Interval() const {
    return type_type() == org::apache::arrow::flatbuf::Type::Interval ? static_cast<const org::apache::arrow::flatbuf::Interval *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::List *type_as_List() const {
    return type_type() == org::apache::arrow::flatbuf::Type::List ? static_cast<const org::apache::arrow::flatbuf::List *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::Struct_ *type_as_Struct_() const {
    return type_type() == org::apache::arrow::flatbuf::Type::Struct_ ? static_cast<const org::apache::arrow::flatbuf::Struct_ *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::Union *type_as_Union() const {
    return type_type() == org::apache::arrow::flatbuf::Type::Union ? static_cast<const org::apache::arrow::flatbuf::Union *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::FixedSizeBinary *type_as_FixedSizeBinary() const {
    return type_type() == org::apache::arrow::flatbuf::Type::FixedSizeBinary ? static_cast<const org::apache::arrow::flatbuf::FixedSizeBinary *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::FixedSizeList *type_as_FixedSizeList() const {
    return type_type() == org::apache::arrow::flatbuf::Type::FixedSizeList ? static_cast<const org::apache::arrow::flatbuf::FixedSizeList *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::Map *type_as_Map() const {
    return type_type() == org::apache::arrow::flatbuf::Type::Map ? static_cast<const org::apache::arrow::flatbuf::Map *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::Duration *type_as_Duration() const {
    return type_type() == org::apache::arrow::flatbuf::Type::Duration ? static_cast<const org::apache::arrow::flatbuf::Duration *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::LargeBinary *type_as_LargeBinary() const {
    return type_type() == org::apache::arrow::flatbuf::Type::LargeBinary ? static_cast<const org::apache::arrow::flatbuf::LargeBinary *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::LargeUtf8 *type_as_LargeUtf8() const {
    return type_type() == org::apache::arrow::flatbuf::Type::LargeUtf8 ? static_cast<const org::apache::arrow::flatbuf::LargeUtf8 *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::LargeList *type_as_LargeList() const {
    return type_type() == org::apache::arrow::flatbuf::Type::LargeList ? static_cast<const org::apache::arrow::flatbuf::LargeList *>(type()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_TYPE_TYPE) &&
           VerifyOffset(verifier, VT_TYPE) &&
           VerifyType(verifier, type(), type_type()) &&
           verifier.EndTable();
  }
};

template<> inline const org::apache::arrow::flatbuf::Null *DirectOutputType::type_as<org::apache::arrow::flatbuf::Null>() const {
  return type_as_Null();
}

template<> inline const org::apache::arrow::flatbuf::Int *DirectOutputType::type_as<org::apache::arrow::flatbuf::Int>() const {
  return type_as_Int();
}

template<> inline const org::apache::arrow::flatbuf::FloatingPoint *DirectOutputType::type_as<org::apache::arrow::flatbuf::FloatingPoint>() const {
  return type_as_FloatingPoint();
}

template<> inline const org::apache::arrow::flatbuf::Binary *DirectOutputType::type_as<org::apache::arrow::flatbuf::Binary>() const {
  return type_as_Binary();
}

template<> inline const org::apache::arrow::flatbuf::Utf8 *DirectOutputType::type_as<org::apache::arrow::flatbuf::Utf8>() const {
  return type_as_Utf8();
}

template<> inline const org::apache::arrow::flatbuf::Bool *DirectOutputType::type_as<org::apache::arrow::flatbuf::Bool>() const {
  return type_as_Bool();
}

template<> inline const org::apache::arrow::flatbuf::Decimal *DirectOutputType::type_as<org::apache::arrow::flatbuf::Decimal>() const {
  return type_as_Decimal();
}

template<> inline const org::apache::arrow::flatbuf::Date *DirectOutputType::type_as<org::apache::arrow::flatbuf::Date>() const {
  return type_as_Date();
}

template<> inline const org::apache::arrow::flatbuf::Time *DirectOutputType::type_as<org::apache::arrow::flatbuf::Time>() const {
  return type_as_Time();
}

template<> inline const org::apache::arrow::flatbuf::Timestamp *DirectOutputType::type_as<org::apache::arrow::flatbuf::Timestamp>() const {
  return type_as_Timestamp();
}

template<> inline const org::apache::arrow::flatbuf::Interval *DirectOutputType::type_as<org::apache::arrow::flatbuf::Interval>() const {
  return type_as_Interval();
}

template<> inline const org::apache::arrow::flatbuf::List *DirectOutputType::type_as<org::apache::arrow::flatbuf::List>() const {
  return type_as_List();
}

template<> inline const org::apache::arrow::flatbuf::Struct_ *DirectOutputType::type_as<org::apache::arrow::flatbuf::Struct_>() const {
  return type_as_Struct_();
}

template<> inline const org::apache::arrow::flatbuf::Union *DirectOutputType::type_as<org::apache::arrow::flatbuf::Union>() const {
  return type_as_Union();
}

template<> inline const org::apache::arrow::flatbuf::FixedSizeBinary *DirectOutputType::type_as<org::apache::arrow::flatbuf::FixedSizeBinary>() const {
  return type_as_FixedSizeBinary();
}

template<> inline const org::apache::arrow::flatbuf::FixedSizeList *DirectOutputType::type_as<org::apache::arrow::flatbuf::FixedSizeList>() const {
  return type_as_FixedSizeList();
}

template<> inline const org::apache::arrow::flatbuf::Map *DirectOutputType::type_as<org::apache::arrow::flatbuf::Map>() const {
  return type_as_Map();
}

template<> inline const org::apache::arrow::flatbuf::Duration *DirectOutputType::type_as<org::apache::arrow::flatbuf::Duration>() const {
  return type_as_Duration();
}

template<> inline const org::apache::arrow::flatbuf::LargeBinary *DirectOutputType::type_as<org::apache::arrow::flatbuf::LargeBinary>() const {
  return type_as_LargeBinary();
}

template<> inline const org::apache::arrow::flatbuf::LargeUtf8 *DirectOutputType::type_as<org::apache::arrow::flatbuf::LargeUtf8>() const {
  return type_as_LargeUtf8();
}

template<> inline const org::apache::arrow::flatbuf::LargeList *DirectOutputType::type_as<org::apache::arrow::flatbuf::LargeList>() const {
  return type_as_LargeList();
}

struct DirectOutputTypeBuilder {
  typedef DirectOutputType Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type_type(org::apache::arrow::flatbuf::Type type_type) {
    fbb_.AddElement<uint8_t>(DirectOutputType::VT_TYPE_TYPE, static_cast<uint8_t>(type_type), 0);
  }
  void add_type(flatbuffers::Offset<void> type) {
    fbb_.AddOffset(DirectOutputType::VT_TYPE, type);
  }
  explicit DirectOutputTypeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DirectOutputTypeBuilder &operator=(const DirectOutputTypeBuilder &);
  flatbuffers::Offset<DirectOutputType> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DirectOutputType>(end);
    return o;
  }
};

inline flatbuffers::Offset<DirectOutputType> CreateDirectOutputType(
    flatbuffers::FlatBufferBuilder &_fbb,
    org::apache::arrow::flatbuf::Type type_type = org::apache::arrow::flatbuf::Type::NONE,
    flatbuffers::Offset<void> type = 0) {
  DirectOutputTypeBuilder builder_(_fbb);
  builder_.add_type(type);
  builder_.add_type_type(type_type);
  return builder_.Finish();
}

struct ComplexOutputType FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ComplexOutputTypeBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ComplexOutputTypeBuilder {
  typedef ComplexOutputType Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ComplexOutputTypeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ComplexOutputTypeBuilder &operator=(const ComplexOutputTypeBuilder &);
  flatbuffers::Offset<ComplexOutputType> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ComplexOutputType>(end);
    return o;
  }
};

inline flatbuffers::Offset<ComplexOutputType> CreateComplexOutputType(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ComplexOutputTypeBuilder builder_(_fbb);
  return builder_.Finish();
}

/// TODO(cpcloud): why is this not a single `type` field?
///                is this an array of *possible* types that an argument could be?
struct DirectArgument FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DirectArgumentBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPES_TYPE = 4,
    VT_TYPES = 6
  };
  const flatbuffers::Vector<uint8_t> *types_type() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_TYPES_TYPE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<void>> *types() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<void>> *>(VT_TYPES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TYPES_TYPE) &&
           verifier.VerifyVector(types_type()) &&
           VerifyOffset(verifier, VT_TYPES) &&
           verifier.VerifyVector(types()) &&
           VerifyTypeVector(verifier, types(), types_type()) &&
           verifier.EndTable();
  }
};

struct DirectArgumentBuilder {
  typedef DirectArgument Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_types_type(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> types_type) {
    fbb_.AddOffset(DirectArgument::VT_TYPES_TYPE, types_type);
  }
  void add_types(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> types) {
    fbb_.AddOffset(DirectArgument::VT_TYPES, types);
  }
  explicit DirectArgumentBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DirectArgumentBuilder &operator=(const DirectArgumentBuilder &);
  flatbuffers::Offset<DirectArgument> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DirectArgument>(end);
    return o;
  }
};

inline flatbuffers::Offset<DirectArgument> CreateDirectArgument(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> types_type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> types = 0) {
  DirectArgumentBuilder builder_(_fbb);
  builder_.add_types(types);
  builder_.add_types_type(types_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<DirectArgument> CreateDirectArgumentDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *types_type = nullptr,
    const std::vector<flatbuffers::Offset<void>> *types = nullptr) {
  auto types_type__ = types_type ? _fbb.CreateVector<uint8_t>(*types_type) : 0;
  auto types__ = types ? _fbb.CreateVector<flatbuffers::Offset<void>>(*types) : 0;
  return org::apache::arrow::ir::flatbuf::CreateDirectArgument(
      _fbb,
      types_type__,
      types__);
}

/// TODO(cpcloud)
/// Is this a convenience, or something that supports a particular use case?
///
struct WildcardArgument FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef WildcardArgumentBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MINIMUM_COUNT = 4,
    VT_MAXIMUM_COUNT = 6,
    VT_TYPE = 8
  };
  uint32_t minimum_count() const {
    return GetField<uint32_t>(VT_MINIMUM_COUNT, 0);
  }
  uint32_t maximum_count() const {
    return GetField<uint32_t>(VT_MAXIMUM_COUNT, 0);
  }
  const org::apache::arrow::ir::flatbuf::DirectArgument *type() const {
    return GetPointer<const org::apache::arrow::ir::flatbuf::DirectArgument *>(VT_TYPE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_MINIMUM_COUNT) &&
           VerifyField<uint32_t>(verifier, VT_MAXIMUM_COUNT) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyTable(type()) &&
           verifier.EndTable();
  }
};

struct WildcardArgumentBuilder {
  typedef WildcardArgument Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_minimum_count(uint32_t minimum_count) {
    fbb_.AddElement<uint32_t>(WildcardArgument::VT_MINIMUM_COUNT, minimum_count, 0);
  }
  void add_maximum_count(uint32_t maximum_count) {
    fbb_.AddElement<uint32_t>(WildcardArgument::VT_MAXIMUM_COUNT, maximum_count, 0);
  }
  void add_type(flatbuffers::Offset<org::apache::arrow::ir::flatbuf::DirectArgument> type) {
    fbb_.AddOffset(WildcardArgument::VT_TYPE, type);
  }
  explicit WildcardArgumentBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WildcardArgumentBuilder &operator=(const WildcardArgumentBuilder &);
  flatbuffers::Offset<WildcardArgument> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WildcardArgument>(end);
    return o;
  }
};

inline flatbuffers::Offset<WildcardArgument> CreateWildcardArgument(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t minimum_count = 0,
    uint32_t maximum_count = 0,
    flatbuffers::Offset<org::apache::arrow::ir::flatbuf::DirectArgument> type = 0) {
  WildcardArgumentBuilder builder_(_fbb);
  builder_.add_type(type);
  builder_.add_maximum_count(maximum_count);
  builder_.add_minimum_count(minimum_count);
  return builder_.Finish();
}

struct FunctionSignature FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FunctionSignatureBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FUNCTION_ID = 4,
    VT_NAME = 6,
    VT_ARGUMENTS_TYPE = 8,
    VT_ARGUMENTS = 10,
    VT_OUTPUT_TYPE = 12,
    VT_OUTPUT = 14
  };
  const org::apache::arrow::ir::flatbuf::FunctionId *function_id() const {
    return GetPointer<const org::apache::arrow::ir::flatbuf::FunctionId *>(VT_FUNCTION_ID);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<uint8_t> *arguments_type() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_ARGUMENTS_TYPE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<void>> *arguments() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<void>> *>(VT_ARGUMENTS);
  }
  org::apache::arrow::ir::flatbuf::OutputDerivation output_type() const {
    return static_cast<org::apache::arrow::ir::flatbuf::OutputDerivation>(GetField<uint8_t>(VT_OUTPUT_TYPE, 0));
  }
  const void *output() const {
    return GetPointer<const void *>(VT_OUTPUT);
  }
  template<typename T> const T *output_as() const;
  const org::apache::arrow::ir::flatbuf::DirectOutputType *output_as_DirectOutputType() const {
    return output_type() == org::apache::arrow::ir::flatbuf::OutputDerivation::DirectOutputType ? static_cast<const org::apache::arrow::ir::flatbuf::DirectOutputType *>(output()) : nullptr;
  }
  const org::apache::arrow::ir::flatbuf::ComplexOutputType *output_as_ComplexOutputType() const {
    return output_type() == org::apache::arrow::ir::flatbuf::OutputDerivation::ComplexOutputType ? static_cast<const org::apache::arrow::ir::flatbuf::ComplexOutputType *>(output()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FUNCTION_ID) &&
           verifier.VerifyTable(function_id()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_ARGUMENTS_TYPE) &&
           verifier.VerifyVector(arguments_type()) &&
           VerifyOffset(verifier, VT_ARGUMENTS) &&
           verifier.VerifyVector(arguments()) &&
           VerifyArgumentVector(verifier, arguments(), arguments_type()) &&
           VerifyField<uint8_t>(verifier, VT_OUTPUT_TYPE) &&
           VerifyOffset(verifier, VT_OUTPUT) &&
           VerifyOutputDerivation(verifier, output(), output_type()) &&
           verifier.EndTable();
  }
};

template<> inline const org::apache::arrow::ir::flatbuf::DirectOutputType *FunctionSignature::output_as<org::apache::arrow::ir::flatbuf::DirectOutputType>() const {
  return output_as_DirectOutputType();
}

template<> inline const org::apache::arrow::ir::flatbuf::ComplexOutputType *FunctionSignature::output_as<org::apache::arrow::ir::flatbuf::ComplexOutputType>() const {
  return output_as_ComplexOutputType();
}

struct FunctionSignatureBuilder {
  typedef FunctionSignature Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_function_id(flatbuffers::Offset<org::apache::arrow::ir::flatbuf::FunctionId> function_id) {
    fbb_.AddOffset(FunctionSignature::VT_FUNCTION_ID, function_id);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(FunctionSignature::VT_NAME, name);
  }
  void add_arguments_type(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> arguments_type) {
    fbb_.AddOffset(FunctionSignature::VT_ARGUMENTS_TYPE, arguments_type);
  }
  void add_arguments(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> arguments) {
    fbb_.AddOffset(FunctionSignature::VT_ARGUMENTS, arguments);
  }
  void add_output_type(org::apache::arrow::ir::flatbuf::OutputDerivation output_type) {
    fbb_.AddElement<uint8_t>(FunctionSignature::VT_OUTPUT_TYPE, static_cast<uint8_t>(output_type), 0);
  }
  void add_output(flatbuffers::Offset<void> output) {
    fbb_.AddOffset(FunctionSignature::VT_OUTPUT, output);
  }
  explicit FunctionSignatureBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FunctionSignatureBuilder &operator=(const FunctionSignatureBuilder &);
  flatbuffers::Offset<FunctionSignature> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FunctionSignature>(end);
    return o;
  }
};

inline flatbuffers::Offset<FunctionSignature> CreateFunctionSignature(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::ir::flatbuf::FunctionId> function_id = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> arguments_type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> arguments = 0,
    org::apache::arrow::ir::flatbuf::OutputDerivation output_type = org::apache::arrow::ir::flatbuf::OutputDerivation::NONE,
    flatbuffers::Offset<void> output = 0) {
  FunctionSignatureBuilder builder_(_fbb);
  builder_.add_output(output);
  builder_.add_arguments(arguments);
  builder_.add_arguments_type(arguments_type);
  builder_.add_name(name);
  builder_.add_function_id(function_id);
  builder_.add_output_type(output_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<FunctionSignature> CreateFunctionSignatureDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::ir::flatbuf::FunctionId> function_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *arguments_type = nullptr,
    const std::vector<flatbuffers::Offset<void>> *arguments = nullptr,
    org::apache::arrow::ir::flatbuf::OutputDerivation output_type = org::apache::arrow::ir::flatbuf::OutputDerivation::NONE,
    flatbuffers::Offset<void> output = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto arguments_type__ = arguments_type ? _fbb.CreateVector<uint8_t>(*arguments_type) : 0;
  auto arguments__ = arguments ? _fbb.CreateVector<flatbuffers::Offset<void>>(*arguments) : 0;
  return org::apache::arrow::ir::flatbuf::CreateFunctionSignature(
      _fbb,
      function_id,
      name__,
      arguments_type__,
      arguments__,
      output_type,
      output);
}

inline bool VerifyOutputDerivation(flatbuffers::Verifier &verifier, const void *obj, OutputDerivation type) {
  switch (type) {
    case OutputDerivation::NONE: {
      return true;
    }
    case OutputDerivation::DirectOutputType: {
      auto ptr = reinterpret_cast<const org::apache::arrow::ir::flatbuf::DirectOutputType *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OutputDerivation::ComplexOutputType: {
      auto ptr = reinterpret_cast<const org::apache::arrow::ir::flatbuf::ComplexOutputType *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyOutputDerivationVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyOutputDerivation(
        verifier,  values->Get(i), types->GetEnum<OutputDerivation>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyArgument(flatbuffers::Verifier &verifier, const void *obj, Argument type) {
  switch (type) {
    case Argument::NONE: {
      return true;
    }
    case Argument::WildcardArgument: {
      auto ptr = reinterpret_cast<const org::apache::arrow::ir::flatbuf::WildcardArgument *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Argument::DirectArgument: {
      auto ptr = reinterpret_cast<const org::apache::arrow::ir::flatbuf::DirectArgument *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyArgumentVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyArgument(
        verifier,  values->Get(i), types->GetEnum<Argument>(i))) {
      return false;
    }
  }
  return true;
}

inline const org::apache::arrow::ir::flatbuf::FunctionSignature *GetFunctionSignature(const void *buf) {
  return flatbuffers::GetRoot<org::apache::arrow::ir::flatbuf::FunctionSignature>(buf);
}

inline const org::apache::arrow::ir::flatbuf::FunctionSignature *GetSizePrefixedFunctionSignature(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<org::apache::arrow::ir::flatbuf::FunctionSignature>(buf);
}

inline bool VerifyFunctionSignatureBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<org::apache::arrow::ir::flatbuf::FunctionSignature>(nullptr);
}

inline bool VerifySizePrefixedFunctionSignatureBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<org::apache::arrow::ir::flatbuf::FunctionSignature>(nullptr);
}

inline void FinishFunctionSignatureBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<org::apache::arrow::ir::flatbuf::FunctionSignature> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedFunctionSignatureBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<org::apache::arrow::ir::flatbuf::FunctionSignature> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace flatbuf
}  // namespace ir
}  // namespace arrow
}  // namespace apache
}  // namespace org

#endif  // FLATBUFFERS_GENERATED_IRFUNCTION_ORG_APACHE_ARROW_IR_FLATBUF_H_
