// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_IRLITERAL_ORG_APACHE_ARROW_IR_FLATBUF_H_
#define FLATBUFFERS_GENERATED_IRLITERAL_ORG_APACHE_ARROW_IR_FLATBUF_H_

#include "flatbuffers/flatbuffers.h"

#include "IRFunction_generated.h"
#include "Schema_generated.h"

namespace org {
namespace apache {
namespace arrow {
namespace ir {
namespace flatbuf {

struct RexLiteral;
struct RexLiteralBuilder;

struct ArrayLiteral;
struct ArrayLiteralBuilder;

struct StructLiteral;
struct StructLiteralBuilder;

struct KeyValue;
struct KeyValueBuilder;

struct MapLiteral;
struct MapLiteralBuilder;

struct I8Literal;
struct I8LiteralBuilder;

struct I16Literal;
struct I16LiteralBuilder;

struct I32Literal;
struct I32LiteralBuilder;

struct I64Literal;
struct I64LiteralBuilder;

struct U8Literal;
struct U8LiteralBuilder;

struct U16Literal;
struct U16LiteralBuilder;

struct U32Literal;
struct U32LiteralBuilder;

struct U64Literal;
struct U64LiteralBuilder;

struct HalfFloatLiteral;
struct HalfFloatLiteralBuilder;

struct FloatLiteral;
struct FloatLiteralBuilder;

struct DoubleLiteral;
struct DoubleLiteralBuilder;

struct DecimalLiteral;
struct DecimalLiteralBuilder;

struct BooleanLiteral;
struct BooleanLiteralBuilder;

struct DateLiteral;
struct DateLiteralBuilder;

struct TimeLiteral;
struct TimeLiteralBuilder;

struct TimestampLiteral;
struct TimestampLiteralBuilder;

struct BinaryLiteral;
struct BinaryLiteralBuilder;

struct StringLiteral;
struct StringLiteralBuilder;

enum class RexLiteralValue : uint8_t {
  NONE = 0,
  BooleanLiteral = 1,
  I8Literal = 2,
  I16Literal = 3,
  I32Literal = 4,
  I64Literal = 5,
  U8Literal = 6,
  U16Literal = 7,
  U32Literal = 8,
  U64Literal = 9,
  DateLiteral = 10,
  TimeLiteral = 11,
  TimestampLiteral = 12,
  DecimalLiteral = 13,
  HalfFloatLiteral = 14,
  FloatLiteral = 15,
  DoubleLiteral = 16,
  ArrayLiteral = 17,
  StructLiteral = 18,
  MapLiteral = 19,
  StringLiteral = 20,
  BinaryLiteral = 21,
  MIN = NONE,
  MAX = BinaryLiteral
};

inline const RexLiteralValue (&EnumValuesRexLiteralValue())[22] {
  static const RexLiteralValue values[] = {
    RexLiteralValue::NONE,
    RexLiteralValue::BooleanLiteral,
    RexLiteralValue::I8Literal,
    RexLiteralValue::I16Literal,
    RexLiteralValue::I32Literal,
    RexLiteralValue::I64Literal,
    RexLiteralValue::U8Literal,
    RexLiteralValue::U16Literal,
    RexLiteralValue::U32Literal,
    RexLiteralValue::U64Literal,
    RexLiteralValue::DateLiteral,
    RexLiteralValue::TimeLiteral,
    RexLiteralValue::TimestampLiteral,
    RexLiteralValue::DecimalLiteral,
    RexLiteralValue::HalfFloatLiteral,
    RexLiteralValue::FloatLiteral,
    RexLiteralValue::DoubleLiteral,
    RexLiteralValue::ArrayLiteral,
    RexLiteralValue::StructLiteral,
    RexLiteralValue::MapLiteral,
    RexLiteralValue::StringLiteral,
    RexLiteralValue::BinaryLiteral
  };
  return values;
}

inline const char * const *EnumNamesRexLiteralValue() {
  static const char * const names[23] = {
    "NONE",
    "BooleanLiteral",
    "I8Literal",
    "I16Literal",
    "I32Literal",
    "I64Literal",
    "U8Literal",
    "U16Literal",
    "U32Literal",
    "U64Literal",
    "DateLiteral",
    "TimeLiteral",
    "TimestampLiteral",
    "DecimalLiteral",
    "HalfFloatLiteral",
    "FloatLiteral",
    "DoubleLiteral",
    "ArrayLiteral",
    "StructLiteral",
    "MapLiteral",
    "StringLiteral",
    "BinaryLiteral",
    nullptr
  };
  return names;
}

inline const char *EnumNameRexLiteralValue(RexLiteralValue e) {
  if (flatbuffers::IsOutRange(e, RexLiteralValue::NONE, RexLiteralValue::BinaryLiteral)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRexLiteralValue()[index];
}

template<typename T> struct RexLiteralValueTraits {
  static const RexLiteralValue enum_value = RexLiteralValue::NONE;
};

template<> struct RexLiteralValueTraits<org::apache::arrow::ir::flatbuf::BooleanLiteral> {
  static const RexLiteralValue enum_value = RexLiteralValue::BooleanLiteral;
};

template<> struct RexLiteralValueTraits<org::apache::arrow::ir::flatbuf::I8Literal> {
  static const RexLiteralValue enum_value = RexLiteralValue::I8Literal;
};

template<> struct RexLiteralValueTraits<org::apache::arrow::ir::flatbuf::I16Literal> {
  static const RexLiteralValue enum_value = RexLiteralValue::I16Literal;
};

template<> struct RexLiteralValueTraits<org::apache::arrow::ir::flatbuf::I32Literal> {
  static const RexLiteralValue enum_value = RexLiteralValue::I32Literal;
};

template<> struct RexLiteralValueTraits<org::apache::arrow::ir::flatbuf::I64Literal> {
  static const RexLiteralValue enum_value = RexLiteralValue::I64Literal;
};

template<> struct RexLiteralValueTraits<org::apache::arrow::ir::flatbuf::U8Literal> {
  static const RexLiteralValue enum_value = RexLiteralValue::U8Literal;
};

template<> struct RexLiteralValueTraits<org::apache::arrow::ir::flatbuf::U16Literal> {
  static const RexLiteralValue enum_value = RexLiteralValue::U16Literal;
};

template<> struct RexLiteralValueTraits<org::apache::arrow::ir::flatbuf::U32Literal> {
  static const RexLiteralValue enum_value = RexLiteralValue::U32Literal;
};

template<> struct RexLiteralValueTraits<org::apache::arrow::ir::flatbuf::U64Literal> {
  static const RexLiteralValue enum_value = RexLiteralValue::U64Literal;
};

template<> struct RexLiteralValueTraits<org::apache::arrow::ir::flatbuf::DateLiteral> {
  static const RexLiteralValue enum_value = RexLiteralValue::DateLiteral;
};

template<> struct RexLiteralValueTraits<org::apache::arrow::ir::flatbuf::TimeLiteral> {
  static const RexLiteralValue enum_value = RexLiteralValue::TimeLiteral;
};

template<> struct RexLiteralValueTraits<org::apache::arrow::ir::flatbuf::TimestampLiteral> {
  static const RexLiteralValue enum_value = RexLiteralValue::TimestampLiteral;
};

template<> struct RexLiteralValueTraits<org::apache::arrow::ir::flatbuf::DecimalLiteral> {
  static const RexLiteralValue enum_value = RexLiteralValue::DecimalLiteral;
};

template<> struct RexLiteralValueTraits<org::apache::arrow::ir::flatbuf::HalfFloatLiteral> {
  static const RexLiteralValue enum_value = RexLiteralValue::HalfFloatLiteral;
};

template<> struct RexLiteralValueTraits<org::apache::arrow::ir::flatbuf::FloatLiteral> {
  static const RexLiteralValue enum_value = RexLiteralValue::FloatLiteral;
};

template<> struct RexLiteralValueTraits<org::apache::arrow::ir::flatbuf::DoubleLiteral> {
  static const RexLiteralValue enum_value = RexLiteralValue::DoubleLiteral;
};

template<> struct RexLiteralValueTraits<org::apache::arrow::ir::flatbuf::ArrayLiteral> {
  static const RexLiteralValue enum_value = RexLiteralValue::ArrayLiteral;
};

template<> struct RexLiteralValueTraits<org::apache::arrow::ir::flatbuf::StructLiteral> {
  static const RexLiteralValue enum_value = RexLiteralValue::StructLiteral;
};

template<> struct RexLiteralValueTraits<org::apache::arrow::ir::flatbuf::MapLiteral> {
  static const RexLiteralValue enum_value = RexLiteralValue::MapLiteral;
};

template<> struct RexLiteralValueTraits<org::apache::arrow::ir::flatbuf::StringLiteral> {
  static const RexLiteralValue enum_value = RexLiteralValue::StringLiteral;
};

template<> struct RexLiteralValueTraits<org::apache::arrow::ir::flatbuf::BinaryLiteral> {
  static const RexLiteralValue enum_value = RexLiteralValue::BinaryLiteral;
};

bool VerifyRexLiteralValue(flatbuffers::Verifier &verifier, const void *obj, RexLiteralValue type);
bool VerifyRexLiteralValueVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct RexLiteral FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RexLiteralBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE_TYPE = 4,
    VT_VALUE = 6
  };
  org::apache::arrow::ir::flatbuf::RexLiteralValue value_type() const {
    return static_cast<org::apache::arrow::ir::flatbuf::RexLiteralValue>(GetField<uint8_t>(VT_VALUE_TYPE, 0));
  }
  const void *value() const {
    return GetPointer<const void *>(VT_VALUE);
  }
  template<typename T> const T *value_as() const;
  const org::apache::arrow::ir::flatbuf::BooleanLiteral *value_as_BooleanLiteral() const {
    return value_type() == org::apache::arrow::ir::flatbuf::RexLiteralValue::BooleanLiteral ? static_cast<const org::apache::arrow::ir::flatbuf::BooleanLiteral *>(value()) : nullptr;
  }
  const org::apache::arrow::ir::flatbuf::I8Literal *value_as_I8Literal() const {
    return value_type() == org::apache::arrow::ir::flatbuf::RexLiteralValue::I8Literal ? static_cast<const org::apache::arrow::ir::flatbuf::I8Literal *>(value()) : nullptr;
  }
  const org::apache::arrow::ir::flatbuf::I16Literal *value_as_I16Literal() const {
    return value_type() == org::apache::arrow::ir::flatbuf::RexLiteralValue::I16Literal ? static_cast<const org::apache::arrow::ir::flatbuf::I16Literal *>(value()) : nullptr;
  }
  const org::apache::arrow::ir::flatbuf::I32Literal *value_as_I32Literal() const {
    return value_type() == org::apache::arrow::ir::flatbuf::RexLiteralValue::I32Literal ? static_cast<const org::apache::arrow::ir::flatbuf::I32Literal *>(value()) : nullptr;
  }
  const org::apache::arrow::ir::flatbuf::I64Literal *value_as_I64Literal() const {
    return value_type() == org::apache::arrow::ir::flatbuf::RexLiteralValue::I64Literal ? static_cast<const org::apache::arrow::ir::flatbuf::I64Literal *>(value()) : nullptr;
  }
  const org::apache::arrow::ir::flatbuf::U8Literal *value_as_U8Literal() const {
    return value_type() == org::apache::arrow::ir::flatbuf::RexLiteralValue::U8Literal ? static_cast<const org::apache::arrow::ir::flatbuf::U8Literal *>(value()) : nullptr;
  }
  const org::apache::arrow::ir::flatbuf::U16Literal *value_as_U16Literal() const {
    return value_type() == org::apache::arrow::ir::flatbuf::RexLiteralValue::U16Literal ? static_cast<const org::apache::arrow::ir::flatbuf::U16Literal *>(value()) : nullptr;
  }
  const org::apache::arrow::ir::flatbuf::U32Literal *value_as_U32Literal() const {
    return value_type() == org::apache::arrow::ir::flatbuf::RexLiteralValue::U32Literal ? static_cast<const org::apache::arrow::ir::flatbuf::U32Literal *>(value()) : nullptr;
  }
  const org::apache::arrow::ir::flatbuf::U64Literal *value_as_U64Literal() const {
    return value_type() == org::apache::arrow::ir::flatbuf::RexLiteralValue::U64Literal ? static_cast<const org::apache::arrow::ir::flatbuf::U64Literal *>(value()) : nullptr;
  }
  const org::apache::arrow::ir::flatbuf::DateLiteral *value_as_DateLiteral() const {
    return value_type() == org::apache::arrow::ir::flatbuf::RexLiteralValue::DateLiteral ? static_cast<const org::apache::arrow::ir::flatbuf::DateLiteral *>(value()) : nullptr;
  }
  const org::apache::arrow::ir::flatbuf::TimeLiteral *value_as_TimeLiteral() const {
    return value_type() == org::apache::arrow::ir::flatbuf::RexLiteralValue::TimeLiteral ? static_cast<const org::apache::arrow::ir::flatbuf::TimeLiteral *>(value()) : nullptr;
  }
  const org::apache::arrow::ir::flatbuf::TimestampLiteral *value_as_TimestampLiteral() const {
    return value_type() == org::apache::arrow::ir::flatbuf::RexLiteralValue::TimestampLiteral ? static_cast<const org::apache::arrow::ir::flatbuf::TimestampLiteral *>(value()) : nullptr;
  }
  const org::apache::arrow::ir::flatbuf::DecimalLiteral *value_as_DecimalLiteral() const {
    return value_type() == org::apache::arrow::ir::flatbuf::RexLiteralValue::DecimalLiteral ? static_cast<const org::apache::arrow::ir::flatbuf::DecimalLiteral *>(value()) : nullptr;
  }
  const org::apache::arrow::ir::flatbuf::HalfFloatLiteral *value_as_HalfFloatLiteral() const {
    return value_type() == org::apache::arrow::ir::flatbuf::RexLiteralValue::HalfFloatLiteral ? static_cast<const org::apache::arrow::ir::flatbuf::HalfFloatLiteral *>(value()) : nullptr;
  }
  const org::apache::arrow::ir::flatbuf::FloatLiteral *value_as_FloatLiteral() const {
    return value_type() == org::apache::arrow::ir::flatbuf::RexLiteralValue::FloatLiteral ? static_cast<const org::apache::arrow::ir::flatbuf::FloatLiteral *>(value()) : nullptr;
  }
  const org::apache::arrow::ir::flatbuf::DoubleLiteral *value_as_DoubleLiteral() const {
    return value_type() == org::apache::arrow::ir::flatbuf::RexLiteralValue::DoubleLiteral ? static_cast<const org::apache::arrow::ir::flatbuf::DoubleLiteral *>(value()) : nullptr;
  }
  const org::apache::arrow::ir::flatbuf::ArrayLiteral *value_as_ArrayLiteral() const {
    return value_type() == org::apache::arrow::ir::flatbuf::RexLiteralValue::ArrayLiteral ? static_cast<const org::apache::arrow::ir::flatbuf::ArrayLiteral *>(value()) : nullptr;
  }
  const org::apache::arrow::ir::flatbuf::StructLiteral *value_as_StructLiteral() const {
    return value_type() == org::apache::arrow::ir::flatbuf::RexLiteralValue::StructLiteral ? static_cast<const org::apache::arrow::ir::flatbuf::StructLiteral *>(value()) : nullptr;
  }
  const org::apache::arrow::ir::flatbuf::MapLiteral *value_as_MapLiteral() const {
    return value_type() == org::apache::arrow::ir::flatbuf::RexLiteralValue::MapLiteral ? static_cast<const org::apache::arrow::ir::flatbuf::MapLiteral *>(value()) : nullptr;
  }
  const org::apache::arrow::ir::flatbuf::StringLiteral *value_as_StringLiteral() const {
    return value_type() == org::apache::arrow::ir::flatbuf::RexLiteralValue::StringLiteral ? static_cast<const org::apache::arrow::ir::flatbuf::StringLiteral *>(value()) : nullptr;
  }
  const org::apache::arrow::ir::flatbuf::BinaryLiteral *value_as_BinaryLiteral() const {
    return value_type() == org::apache::arrow::ir::flatbuf::RexLiteralValue::BinaryLiteral ? static_cast<const org::apache::arrow::ir::flatbuf::BinaryLiteral *>(value()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VALUE_TYPE) &&
           VerifyOffset(verifier, VT_VALUE) &&
           VerifyRexLiteralValue(verifier, value(), value_type()) &&
           verifier.EndTable();
  }
};

template<> inline const org::apache::arrow::ir::flatbuf::BooleanLiteral *RexLiteral::value_as<org::apache::arrow::ir::flatbuf::BooleanLiteral>() const {
  return value_as_BooleanLiteral();
}

template<> inline const org::apache::arrow::ir::flatbuf::I8Literal *RexLiteral::value_as<org::apache::arrow::ir::flatbuf::I8Literal>() const {
  return value_as_I8Literal();
}

template<> inline const org::apache::arrow::ir::flatbuf::I16Literal *RexLiteral::value_as<org::apache::arrow::ir::flatbuf::I16Literal>() const {
  return value_as_I16Literal();
}

template<> inline const org::apache::arrow::ir::flatbuf::I32Literal *RexLiteral::value_as<org::apache::arrow::ir::flatbuf::I32Literal>() const {
  return value_as_I32Literal();
}

template<> inline const org::apache::arrow::ir::flatbuf::I64Literal *RexLiteral::value_as<org::apache::arrow::ir::flatbuf::I64Literal>() const {
  return value_as_I64Literal();
}

template<> inline const org::apache::arrow::ir::flatbuf::U8Literal *RexLiteral::value_as<org::apache::arrow::ir::flatbuf::U8Literal>() const {
  return value_as_U8Literal();
}

template<> inline const org::apache::arrow::ir::flatbuf::U16Literal *RexLiteral::value_as<org::apache::arrow::ir::flatbuf::U16Literal>() const {
  return value_as_U16Literal();
}

template<> inline const org::apache::arrow::ir::flatbuf::U32Literal *RexLiteral::value_as<org::apache::arrow::ir::flatbuf::U32Literal>() const {
  return value_as_U32Literal();
}

template<> inline const org::apache::arrow::ir::flatbuf::U64Literal *RexLiteral::value_as<org::apache::arrow::ir::flatbuf::U64Literal>() const {
  return value_as_U64Literal();
}

template<> inline const org::apache::arrow::ir::flatbuf::DateLiteral *RexLiteral::value_as<org::apache::arrow::ir::flatbuf::DateLiteral>() const {
  return value_as_DateLiteral();
}

template<> inline const org::apache::arrow::ir::flatbuf::TimeLiteral *RexLiteral::value_as<org::apache::arrow::ir::flatbuf::TimeLiteral>() const {
  return value_as_TimeLiteral();
}

template<> inline const org::apache::arrow::ir::flatbuf::TimestampLiteral *RexLiteral::value_as<org::apache::arrow::ir::flatbuf::TimestampLiteral>() const {
  return value_as_TimestampLiteral();
}

template<> inline const org::apache::arrow::ir::flatbuf::DecimalLiteral *RexLiteral::value_as<org::apache::arrow::ir::flatbuf::DecimalLiteral>() const {
  return value_as_DecimalLiteral();
}

template<> inline const org::apache::arrow::ir::flatbuf::HalfFloatLiteral *RexLiteral::value_as<org::apache::arrow::ir::flatbuf::HalfFloatLiteral>() const {
  return value_as_HalfFloatLiteral();
}

template<> inline const org::apache::arrow::ir::flatbuf::FloatLiteral *RexLiteral::value_as<org::apache::arrow::ir::flatbuf::FloatLiteral>() const {
  return value_as_FloatLiteral();
}

template<> inline const org::apache::arrow::ir::flatbuf::DoubleLiteral *RexLiteral::value_as<org::apache::arrow::ir::flatbuf::DoubleLiteral>() const {
  return value_as_DoubleLiteral();
}

template<> inline const org::apache::arrow::ir::flatbuf::ArrayLiteral *RexLiteral::value_as<org::apache::arrow::ir::flatbuf::ArrayLiteral>() const {
  return value_as_ArrayLiteral();
}

template<> inline const org::apache::arrow::ir::flatbuf::StructLiteral *RexLiteral::value_as<org::apache::arrow::ir::flatbuf::StructLiteral>() const {
  return value_as_StructLiteral();
}

template<> inline const org::apache::arrow::ir::flatbuf::MapLiteral *RexLiteral::value_as<org::apache::arrow::ir::flatbuf::MapLiteral>() const {
  return value_as_MapLiteral();
}

template<> inline const org::apache::arrow::ir::flatbuf::StringLiteral *RexLiteral::value_as<org::apache::arrow::ir::flatbuf::StringLiteral>() const {
  return value_as_StringLiteral();
}

template<> inline const org::apache::arrow::ir::flatbuf::BinaryLiteral *RexLiteral::value_as<org::apache::arrow::ir::flatbuf::BinaryLiteral>() const {
  return value_as_BinaryLiteral();
}

struct RexLiteralBuilder {
  typedef RexLiteral Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value_type(org::apache::arrow::ir::flatbuf::RexLiteralValue value_type) {
    fbb_.AddElement<uint8_t>(RexLiteral::VT_VALUE_TYPE, static_cast<uint8_t>(value_type), 0);
  }
  void add_value(flatbuffers::Offset<void> value) {
    fbb_.AddOffset(RexLiteral::VT_VALUE, value);
  }
  explicit RexLiteralBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RexLiteralBuilder &operator=(const RexLiteralBuilder &);
  flatbuffers::Offset<RexLiteral> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RexLiteral>(end);
    return o;
  }
};

inline flatbuffers::Offset<RexLiteral> CreateRexLiteral(
    flatbuffers::FlatBufferBuilder &_fbb,
    org::apache::arrow::ir::flatbuf::RexLiteralValue value_type = org::apache::arrow::ir::flatbuf::RexLiteralValue::NONE,
    flatbuffers::Offset<void> value = 0) {
  RexLiteralBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_value_type(value_type);
  return builder_.Finish();
}

struct ArrayLiteral FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ArrayLiteralBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::RexLiteral>> *values() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::RexLiteral>> *>(VT_VALUES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUES) &&
           verifier.VerifyVector(values()) &&
           verifier.VerifyVectorOfTables(values()) &&
           verifier.EndTable();
  }
};

struct ArrayLiteralBuilder {
  typedef ArrayLiteral Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_values(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::RexLiteral>>> values) {
    fbb_.AddOffset(ArrayLiteral::VT_VALUES, values);
  }
  explicit ArrayLiteralBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ArrayLiteralBuilder &operator=(const ArrayLiteralBuilder &);
  flatbuffers::Offset<ArrayLiteral> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArrayLiteral>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArrayLiteral> CreateArrayLiteral(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::RexLiteral>>> values = 0) {
  ArrayLiteralBuilder builder_(_fbb);
  builder_.add_values(values);
  return builder_.Finish();
}

inline flatbuffers::Offset<ArrayLiteral> CreateArrayLiteralDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::RexLiteral>> *values = nullptr) {
  auto values__ = values ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::RexLiteral>>(*values) : 0;
  return org::apache::arrow::ir::flatbuf::CreateArrayLiteral(
      _fbb,
      values__);
}

struct StructLiteral FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StructLiteralBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::KeyValue>> *values() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::KeyValue>> *>(VT_VALUES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUES) &&
           verifier.VerifyVector(values()) &&
           verifier.VerifyVectorOfTables(values()) &&
           verifier.EndTable();
  }
};

struct StructLiteralBuilder {
  typedef StructLiteral Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_values(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::KeyValue>>> values) {
    fbb_.AddOffset(StructLiteral::VT_VALUES, values);
  }
  explicit StructLiteralBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StructLiteralBuilder &operator=(const StructLiteralBuilder &);
  flatbuffers::Offset<StructLiteral> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StructLiteral>(end);
    return o;
  }
};

inline flatbuffers::Offset<StructLiteral> CreateStructLiteral(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::KeyValue>>> values = 0) {
  StructLiteralBuilder builder_(_fbb);
  builder_.add_values(values);
  return builder_.Finish();
}

inline flatbuffers::Offset<StructLiteral> CreateStructLiteralDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::KeyValue>> *values = nullptr) {
  auto values__ = values ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::KeyValue>>(*values) : 0;
  return org::apache::arrow::ir::flatbuf::CreateStructLiteral(
      _fbb,
      values__);
}

struct KeyValue FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef KeyValueBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_VALUE = 6
  };
  const flatbuffers::String *key() const {
    return GetPointer<const flatbuffers::String *>(VT_KEY);
  }
  const org::apache::arrow::ir::flatbuf::RexLiteral *value() const {
    return GetPointer<const org::apache::arrow::ir::flatbuf::RexLiteral *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyTable(value()) &&
           verifier.EndTable();
  }
};

struct KeyValueBuilder {
  typedef KeyValue Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_key(flatbuffers::Offset<flatbuffers::String> key) {
    fbb_.AddOffset(KeyValue::VT_KEY, key);
  }
  void add_value(flatbuffers::Offset<org::apache::arrow::ir::flatbuf::RexLiteral> value) {
    fbb_.AddOffset(KeyValue::VT_VALUE, value);
  }
  explicit KeyValueBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  KeyValueBuilder &operator=(const KeyValueBuilder &);
  flatbuffers::Offset<KeyValue> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<KeyValue>(end);
    return o;
  }
};

inline flatbuffers::Offset<KeyValue> CreateKeyValue(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> key = 0,
    flatbuffers::Offset<org::apache::arrow::ir::flatbuf::RexLiteral> value = 0) {
  KeyValueBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key(key);
  return builder_.Finish();
}

inline flatbuffers::Offset<KeyValue> CreateKeyValueDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr,
    flatbuffers::Offset<org::apache::arrow::ir::flatbuf::RexLiteral> value = 0) {
  auto key__ = key ? _fbb.CreateString(key) : 0;
  return org::apache::arrow::ir::flatbuf::CreateKeyValue(
      _fbb,
      key__,
      value);
}

struct MapLiteral FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MapLiteralBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::KeyValue>> *values() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::KeyValue>> *>(VT_VALUES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUES) &&
           verifier.VerifyVector(values()) &&
           verifier.VerifyVectorOfTables(values()) &&
           verifier.EndTable();
  }
};

struct MapLiteralBuilder {
  typedef MapLiteral Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_values(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::KeyValue>>> values) {
    fbb_.AddOffset(MapLiteral::VT_VALUES, values);
  }
  explicit MapLiteralBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MapLiteralBuilder &operator=(const MapLiteralBuilder &);
  flatbuffers::Offset<MapLiteral> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MapLiteral>(end);
    return o;
  }
};

inline flatbuffers::Offset<MapLiteral> CreateMapLiteral(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::KeyValue>>> values = 0) {
  MapLiteralBuilder builder_(_fbb);
  builder_.add_values(values);
  return builder_.Finish();
}

inline flatbuffers::Offset<MapLiteral> CreateMapLiteralDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::KeyValue>> *values = nullptr) {
  auto values__ = values ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::KeyValue>>(*values) : 0;
  return org::apache::arrow::ir::flatbuf::CreateMapLiteral(
      _fbb,
      values__);
}

struct I8Literal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef I8LiteralBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  int8_t value() const {
    return GetField<int8_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct I8LiteralBuilder {
  typedef I8Literal Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(int8_t value) {
    fbb_.AddElement<int8_t>(I8Literal::VT_VALUE, value, 0);
  }
  explicit I8LiteralBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  I8LiteralBuilder &operator=(const I8LiteralBuilder &);
  flatbuffers::Offset<I8Literal> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<I8Literal>(end);
    return o;
  }
};

inline flatbuffers::Offset<I8Literal> CreateI8Literal(
    flatbuffers::FlatBufferBuilder &_fbb,
    int8_t value = 0) {
  I8LiteralBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct I16Literal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef I16LiteralBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  int16_t value() const {
    return GetField<int16_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct I16LiteralBuilder {
  typedef I16Literal Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(int16_t value) {
    fbb_.AddElement<int16_t>(I16Literal::VT_VALUE, value, 0);
  }
  explicit I16LiteralBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  I16LiteralBuilder &operator=(const I16LiteralBuilder &);
  flatbuffers::Offset<I16Literal> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<I16Literal>(end);
    return o;
  }
};

inline flatbuffers::Offset<I16Literal> CreateI16Literal(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t value = 0) {
  I16LiteralBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct I32Literal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef I32LiteralBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  int32_t value() const {
    return GetField<int32_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct I32LiteralBuilder {
  typedef I32Literal Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(int32_t value) {
    fbb_.AddElement<int32_t>(I32Literal::VT_VALUE, value, 0);
  }
  explicit I32LiteralBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  I32LiteralBuilder &operator=(const I32LiteralBuilder &);
  flatbuffers::Offset<I32Literal> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<I32Literal>(end);
    return o;
  }
};

inline flatbuffers::Offset<I32Literal> CreateI32Literal(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t value = 0) {
  I32LiteralBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct I64Literal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef I64LiteralBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  int64_t value() const {
    return GetField<int64_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct I64LiteralBuilder {
  typedef I64Literal Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(int64_t value) {
    fbb_.AddElement<int64_t>(I64Literal::VT_VALUE, value, 0);
  }
  explicit I64LiteralBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  I64LiteralBuilder &operator=(const I64LiteralBuilder &);
  flatbuffers::Offset<I64Literal> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<I64Literal>(end);
    return o;
  }
};

inline flatbuffers::Offset<I64Literal> CreateI64Literal(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t value = 0) {
  I64LiteralBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct U8Literal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef U8LiteralBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  uint8_t value() const {
    return GetField<uint8_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct U8LiteralBuilder {
  typedef U8Literal Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(uint8_t value) {
    fbb_.AddElement<uint8_t>(U8Literal::VT_VALUE, value, 0);
  }
  explicit U8LiteralBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  U8LiteralBuilder &operator=(const U8LiteralBuilder &);
  flatbuffers::Offset<U8Literal> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<U8Literal>(end);
    return o;
  }
};

inline flatbuffers::Offset<U8Literal> CreateU8Literal(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t value = 0) {
  U8LiteralBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct U16Literal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef U16LiteralBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  uint16_t value() const {
    return GetField<uint16_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct U16LiteralBuilder {
  typedef U16Literal Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(uint16_t value) {
    fbb_.AddElement<uint16_t>(U16Literal::VT_VALUE, value, 0);
  }
  explicit U16LiteralBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  U16LiteralBuilder &operator=(const U16LiteralBuilder &);
  flatbuffers::Offset<U16Literal> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<U16Literal>(end);
    return o;
  }
};

inline flatbuffers::Offset<U16Literal> CreateU16Literal(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t value = 0) {
  U16LiteralBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct U32Literal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef U32LiteralBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  uint32_t value() const {
    return GetField<uint32_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct U32LiteralBuilder {
  typedef U32Literal Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(uint32_t value) {
    fbb_.AddElement<uint32_t>(U32Literal::VT_VALUE, value, 0);
  }
  explicit U32LiteralBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  U32LiteralBuilder &operator=(const U32LiteralBuilder &);
  flatbuffers::Offset<U32Literal> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<U32Literal>(end);
    return o;
  }
};

inline flatbuffers::Offset<U32Literal> CreateU32Literal(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t value = 0) {
  U32LiteralBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct U64Literal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef U64LiteralBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  uint64_t value() const {
    return GetField<uint64_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct U64LiteralBuilder {
  typedef U64Literal Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(uint64_t value) {
    fbb_.AddElement<uint64_t>(U64Literal::VT_VALUE, value, 0);
  }
  explicit U64LiteralBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  U64LiteralBuilder &operator=(const U64LiteralBuilder &);
  flatbuffers::Offset<U64Literal> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<U64Literal>(end);
    return o;
  }
};

inline flatbuffers::Offset<U64Literal> CreateU64Literal(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t value = 0) {
  U64LiteralBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct HalfFloatLiteral FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HalfFloatLiteralBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  uint16_t value() const {
    return GetField<uint16_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct HalfFloatLiteralBuilder {
  typedef HalfFloatLiteral Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(uint16_t value) {
    fbb_.AddElement<uint16_t>(HalfFloatLiteral::VT_VALUE, value, 0);
  }
  explicit HalfFloatLiteralBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HalfFloatLiteralBuilder &operator=(const HalfFloatLiteralBuilder &);
  flatbuffers::Offset<HalfFloatLiteral> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HalfFloatLiteral>(end);
    return o;
  }
};

inline flatbuffers::Offset<HalfFloatLiteral> CreateHalfFloatLiteral(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t value = 0) {
  HalfFloatLiteralBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct FloatLiteral FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FloatLiteralBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  float value() const {
    return GetField<float>(VT_VALUE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct FloatLiteralBuilder {
  typedef FloatLiteral Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(float value) {
    fbb_.AddElement<float>(FloatLiteral::VT_VALUE, value, 0.0f);
  }
  explicit FloatLiteralBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FloatLiteralBuilder &operator=(const FloatLiteralBuilder &);
  flatbuffers::Offset<FloatLiteral> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FloatLiteral>(end);
    return o;
  }
};

inline flatbuffers::Offset<FloatLiteral> CreateFloatLiteral(
    flatbuffers::FlatBufferBuilder &_fbb,
    float value = 0.0f) {
  FloatLiteralBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct DoubleLiteral FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DoubleLiteralBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  double value() const {
    return GetField<double>(VT_VALUE, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct DoubleLiteralBuilder {
  typedef DoubleLiteral Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(double value) {
    fbb_.AddElement<double>(DoubleLiteral::VT_VALUE, value, 0.0);
  }
  explicit DoubleLiteralBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DoubleLiteralBuilder &operator=(const DoubleLiteralBuilder &);
  flatbuffers::Offset<DoubleLiteral> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DoubleLiteral>(end);
    return o;
  }
};

inline flatbuffers::Offset<DoubleLiteral> CreateDoubleLiteral(
    flatbuffers::FlatBufferBuilder &_fbb,
    double value = 0.0) {
  DoubleLiteralBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct DecimalLiteral FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DecimalLiteralBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4,
    VT_SCALE = 6,
    VT_PRECISION = 8
  };
  const flatbuffers::Vector<uint8_t> *value() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_VALUE);
  }
  uint8_t scale() const {
    return GetField<uint8_t>(VT_SCALE, 0);
  }
  uint8_t precision() const {
    return GetField<uint8_t>(VT_PRECISION, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           VerifyField<uint8_t>(verifier, VT_SCALE) &&
           VerifyField<uint8_t>(verifier, VT_PRECISION) &&
           verifier.EndTable();
  }
};

struct DecimalLiteralBuilder {
  typedef DecimalLiteral Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> value) {
    fbb_.AddOffset(DecimalLiteral::VT_VALUE, value);
  }
  void add_scale(uint8_t scale) {
    fbb_.AddElement<uint8_t>(DecimalLiteral::VT_SCALE, scale, 0);
  }
  void add_precision(uint8_t precision) {
    fbb_.AddElement<uint8_t>(DecimalLiteral::VT_PRECISION, precision, 0);
  }
  explicit DecimalLiteralBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DecimalLiteralBuilder &operator=(const DecimalLiteralBuilder &);
  flatbuffers::Offset<DecimalLiteral> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DecimalLiteral>(end);
    return o;
  }
};

inline flatbuffers::Offset<DecimalLiteral> CreateDecimalLiteral(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> value = 0,
    uint8_t scale = 0,
    uint8_t precision = 0) {
  DecimalLiteralBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_precision(precision);
  builder_.add_scale(scale);
  return builder_.Finish();
}

inline flatbuffers::Offset<DecimalLiteral> CreateDecimalLiteralDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *value = nullptr,
    uint8_t scale = 0,
    uint8_t precision = 0) {
  auto value__ = value ? _fbb.CreateVector<uint8_t>(*value) : 0;
  return org::apache::arrow::ir::flatbuf::CreateDecimalLiteral(
      _fbb,
      value__,
      scale,
      precision);
}

struct BooleanLiteral FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BooleanLiteralBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  bool value() const {
    return GetField<uint8_t>(VT_VALUE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct BooleanLiteralBuilder {
  typedef BooleanLiteral Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(bool value) {
    fbb_.AddElement<uint8_t>(BooleanLiteral::VT_VALUE, static_cast<uint8_t>(value), 0);
  }
  explicit BooleanLiteralBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BooleanLiteralBuilder &operator=(const BooleanLiteralBuilder &);
  flatbuffers::Offset<BooleanLiteral> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BooleanLiteral>(end);
    return o;
  }
};

inline flatbuffers::Offset<BooleanLiteral> CreateBooleanLiteral(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool value = false) {
  BooleanLiteralBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct DateLiteral FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DateLiteralBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  int64_t value() const {
    return GetField<int64_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct DateLiteralBuilder {
  typedef DateLiteral Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(int64_t value) {
    fbb_.AddElement<int64_t>(DateLiteral::VT_VALUE, value, 0);
  }
  explicit DateLiteralBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DateLiteralBuilder &operator=(const DateLiteralBuilder &);
  flatbuffers::Offset<DateLiteral> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DateLiteral>(end);
    return o;
  }
};

inline flatbuffers::Offset<DateLiteral> CreateDateLiteral(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t value = 0) {
  DateLiteralBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct TimeLiteral FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TimeLiteralBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  int64_t value() const {
    return GetField<int64_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct TimeLiteralBuilder {
  typedef TimeLiteral Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(int64_t value) {
    fbb_.AddElement<int64_t>(TimeLiteral::VT_VALUE, value, 0);
  }
  explicit TimeLiteralBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TimeLiteralBuilder &operator=(const TimeLiteralBuilder &);
  flatbuffers::Offset<TimeLiteral> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TimeLiteral>(end);
    return o;
  }
};

inline flatbuffers::Offset<TimeLiteral> CreateTimeLiteral(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t value = 0) {
  TimeLiteralBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct TimestampLiteral FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TimestampLiteralBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4,
    VT_TIMEZONE = 6
  };
  int64_t value() const {
    return GetField<int64_t>(VT_VALUE, 0);
  }
  const flatbuffers::String *timezone() const {
    return GetPointer<const flatbuffers::String *>(VT_TIMEZONE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_VALUE) &&
           VerifyOffset(verifier, VT_TIMEZONE) &&
           verifier.VerifyString(timezone()) &&
           verifier.EndTable();
  }
};

struct TimestampLiteralBuilder {
  typedef TimestampLiteral Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(int64_t value) {
    fbb_.AddElement<int64_t>(TimestampLiteral::VT_VALUE, value, 0);
  }
  void add_timezone(flatbuffers::Offset<flatbuffers::String> timezone) {
    fbb_.AddOffset(TimestampLiteral::VT_TIMEZONE, timezone);
  }
  explicit TimestampLiteralBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TimestampLiteralBuilder &operator=(const TimestampLiteralBuilder &);
  flatbuffers::Offset<TimestampLiteral> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TimestampLiteral>(end);
    return o;
  }
};

inline flatbuffers::Offset<TimestampLiteral> CreateTimestampLiteral(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t value = 0,
    flatbuffers::Offset<flatbuffers::String> timezone = 0) {
  TimestampLiteralBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_timezone(timezone);
  return builder_.Finish();
}

inline flatbuffers::Offset<TimestampLiteral> CreateTimestampLiteralDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t value = 0,
    const char *timezone = nullptr) {
  auto timezone__ = timezone ? _fbb.CreateString(timezone) : 0;
  return org::apache::arrow::ir::flatbuf::CreateTimestampLiteral(
      _fbb,
      value,
      timezone__);
}

struct BinaryLiteral FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BinaryLiteralBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const flatbuffers::Vector<int8_t> *value() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.EndTable();
  }
};

struct BinaryLiteralBuilder {
  typedef BinaryLiteral Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<flatbuffers::Vector<int8_t>> value) {
    fbb_.AddOffset(BinaryLiteral::VT_VALUE, value);
  }
  explicit BinaryLiteralBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BinaryLiteralBuilder &operator=(const BinaryLiteralBuilder &);
  flatbuffers::Offset<BinaryLiteral> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BinaryLiteral>(end);
    return o;
  }
};

inline flatbuffers::Offset<BinaryLiteral> CreateBinaryLiteral(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> value = 0) {
  BinaryLiteralBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline flatbuffers::Offset<BinaryLiteral> CreateBinaryLiteralDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int8_t> *value = nullptr) {
  auto value__ = value ? _fbb.CreateVector<int8_t>(*value) : 0;
  return org::apache::arrow::ir::flatbuf::CreateBinaryLiteral(
      _fbb,
      value__);
}

struct StringLiteral FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StringLiteralBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const flatbuffers::String *value() const {
    return GetPointer<const flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) &&
           verifier.EndTable();
  }
};

struct StringLiteralBuilder {
  typedef StringLiteral Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<flatbuffers::String> value) {
    fbb_.AddOffset(StringLiteral::VT_VALUE, value);
  }
  explicit StringLiteralBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StringLiteralBuilder &operator=(const StringLiteralBuilder &);
  flatbuffers::Offset<StringLiteral> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StringLiteral>(end);
    return o;
  }
};

inline flatbuffers::Offset<StringLiteral> CreateStringLiteral(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> value = 0) {
  StringLiteralBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline flatbuffers::Offset<StringLiteral> CreateStringLiteralDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *value = nullptr) {
  auto value__ = value ? _fbb.CreateString(value) : 0;
  return org::apache::arrow::ir::flatbuf::CreateStringLiteral(
      _fbb,
      value__);
}

inline bool VerifyRexLiteralValue(flatbuffers::Verifier &verifier, const void *obj, RexLiteralValue type) {
  switch (type) {
    case RexLiteralValue::NONE: {
      return true;
    }
    case RexLiteralValue::BooleanLiteral: {
      auto ptr = reinterpret_cast<const org::apache::arrow::ir::flatbuf::BooleanLiteral *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RexLiteralValue::I8Literal: {
      auto ptr = reinterpret_cast<const org::apache::arrow::ir::flatbuf::I8Literal *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RexLiteralValue::I16Literal: {
      auto ptr = reinterpret_cast<const org::apache::arrow::ir::flatbuf::I16Literal *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RexLiteralValue::I32Literal: {
      auto ptr = reinterpret_cast<const org::apache::arrow::ir::flatbuf::I32Literal *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RexLiteralValue::I64Literal: {
      auto ptr = reinterpret_cast<const org::apache::arrow::ir::flatbuf::I64Literal *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RexLiteralValue::U8Literal: {
      auto ptr = reinterpret_cast<const org::apache::arrow::ir::flatbuf::U8Literal *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RexLiteralValue::U16Literal: {
      auto ptr = reinterpret_cast<const org::apache::arrow::ir::flatbuf::U16Literal *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RexLiteralValue::U32Literal: {
      auto ptr = reinterpret_cast<const org::apache::arrow::ir::flatbuf::U32Literal *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RexLiteralValue::U64Literal: {
      auto ptr = reinterpret_cast<const org::apache::arrow::ir::flatbuf::U64Literal *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RexLiteralValue::DateLiteral: {
      auto ptr = reinterpret_cast<const org::apache::arrow::ir::flatbuf::DateLiteral *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RexLiteralValue::TimeLiteral: {
      auto ptr = reinterpret_cast<const org::apache::arrow::ir::flatbuf::TimeLiteral *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RexLiteralValue::TimestampLiteral: {
      auto ptr = reinterpret_cast<const org::apache::arrow::ir::flatbuf::TimestampLiteral *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RexLiteralValue::DecimalLiteral: {
      auto ptr = reinterpret_cast<const org::apache::arrow::ir::flatbuf::DecimalLiteral *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RexLiteralValue::HalfFloatLiteral: {
      auto ptr = reinterpret_cast<const org::apache::arrow::ir::flatbuf::HalfFloatLiteral *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RexLiteralValue::FloatLiteral: {
      auto ptr = reinterpret_cast<const org::apache::arrow::ir::flatbuf::FloatLiteral *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RexLiteralValue::DoubleLiteral: {
      auto ptr = reinterpret_cast<const org::apache::arrow::ir::flatbuf::DoubleLiteral *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RexLiteralValue::ArrayLiteral: {
      auto ptr = reinterpret_cast<const org::apache::arrow::ir::flatbuf::ArrayLiteral *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RexLiteralValue::StructLiteral: {
      auto ptr = reinterpret_cast<const org::apache::arrow::ir::flatbuf::StructLiteral *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RexLiteralValue::MapLiteral: {
      auto ptr = reinterpret_cast<const org::apache::arrow::ir::flatbuf::MapLiteral *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RexLiteralValue::StringLiteral: {
      auto ptr = reinterpret_cast<const org::apache::arrow::ir::flatbuf::StringLiteral *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RexLiteralValue::BinaryLiteral: {
      auto ptr = reinterpret_cast<const org::apache::arrow::ir::flatbuf::BinaryLiteral *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyRexLiteralValueVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyRexLiteralValue(
        verifier,  values->Get(i), types->GetEnum<RexLiteralValue>(i))) {
      return false;
    }
  }
  return true;
}

inline const org::apache::arrow::ir::flatbuf::RexLiteral *GetRexLiteral(const void *buf) {
  return flatbuffers::GetRoot<org::apache::arrow::ir::flatbuf::RexLiteral>(buf);
}

inline const org::apache::arrow::ir::flatbuf::RexLiteral *GetSizePrefixedRexLiteral(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<org::apache::arrow::ir::flatbuf::RexLiteral>(buf);
}

inline bool VerifyRexLiteralBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<org::apache::arrow::ir::flatbuf::RexLiteral>(nullptr);
}

inline bool VerifySizePrefixedRexLiteralBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<org::apache::arrow::ir::flatbuf::RexLiteral>(nullptr);
}

inline void FinishRexLiteralBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<org::apache::arrow::ir::flatbuf::RexLiteral> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedRexLiteralBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<org::apache::arrow::ir::flatbuf::RexLiteral> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace flatbuf
}  // namespace ir
}  // namespace arrow
}  // namespace apache
}  // namespace org

#endif  // FLATBUFFERS_GENERATED_IRLITERAL_ORG_APACHE_ARROW_IR_FLATBUF_H_
