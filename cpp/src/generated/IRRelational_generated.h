// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_IRRELATIONAL_ORG_APACHE_ARROW_IR_FLATBUF_H_
#define FLATBUFFERS_GENERATED_IRRELATIONAL_ORG_APACHE_ARROW_IR_FLATBUF_H_

#include "flatbuffers/flatbuffers.h"

#include "IRFunction_generated.h"
#include "IRLiteral_generated.h"
#include "IRRowExpression_generated.h"
#include "Schema_generated.h"

namespace org {
namespace apache {
namespace arrow {
namespace ir {
namespace flatbuf {

struct Remap;
struct RemapBuilder;

struct Direct;
struct DirectBuilder;

struct RelCommon;
struct RelCommonBuilder;

struct Hints;
struct HintsBuilder;

struct RuntimeConstraint;
struct RuntimeConstraintBuilder;

struct HintKeyValue;
struct HintKeyValueBuilder;

struct Stats;
struct StatsBuilder;

struct EvenRedistribution;
struct EvenRedistributionBuilder;

struct RedistributeRel;
struct RedistributeRelBuilder;

struct ExpressionRedistribution;
struct ExpressionRedistributionBuilder;

struct Grouping;
struct GroupingBuilder;

struct AggRel;
struct AggRelBuilder;

struct CorrelateRel;
struct CorrelateRelBuilder;

struct JoinRel;
struct JoinRelBuilder;

struct SetRel;
struct SetRelBuilder;

struct SetRelAlt;
struct SetRelAltBuilder;

struct SortRel;
struct SortRelBuilder;

struct ProjectRel;
struct ProjectRelBuilder;

struct FetchRel;
struct FetchRelBuilder;

struct FilterRel;
struct FilterRelBuilder;

struct ReadRel;
struct ReadRelBuilder;

struct LiteralRel;
struct LiteralRelBuilder;

struct WriteRel;
struct WriteRelBuilder;

struct Rel;
struct RelBuilder;

enum class Emit : uint8_t {
  NONE = 0,
  Remap = 1,
  Direct = 2,
  MIN = NONE,
  MAX = Direct
};

inline const Emit (&EnumValuesEmit())[3] {
  static const Emit values[] = {
    Emit::NONE,
    Emit::Remap,
    Emit::Direct
  };
  return values;
}

inline const char * const *EnumNamesEmit() {
  static const char * const names[4] = {
    "NONE",
    "Remap",
    "Direct",
    nullptr
  };
  return names;
}

inline const char *EnumNameEmit(Emit e) {
  if (flatbuffers::IsOutRange(e, Emit::NONE, Emit::Direct)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEmit()[index];
}

template<typename T> struct EmitTraits {
  static const Emit enum_value = Emit::NONE;
};

template<> struct EmitTraits<org::apache::arrow::ir::flatbuf::Remap> {
  static const Emit enum_value = Emit::Remap;
};

template<> struct EmitTraits<org::apache::arrow::ir::flatbuf::Direct> {
  static const Emit enum_value = Emit::Direct;
};

bool VerifyEmit(flatbuffers::Verifier &verifier, const void *obj, Emit type);
bool VerifyEmitVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum class RedistributionMethod : uint8_t {
  NONE = 0,
  ExpressionRedistribution = 1,
  EvenRedistribution = 2,
  MIN = NONE,
  MAX = EvenRedistribution
};

inline const RedistributionMethod (&EnumValuesRedistributionMethod())[3] {
  static const RedistributionMethod values[] = {
    RedistributionMethod::NONE,
    RedistributionMethod::ExpressionRedistribution,
    RedistributionMethod::EvenRedistribution
  };
  return values;
}

inline const char * const *EnumNamesRedistributionMethod() {
  static const char * const names[4] = {
    "NONE",
    "ExpressionRedistribution",
    "EvenRedistribution",
    nullptr
  };
  return names;
}

inline const char *EnumNameRedistributionMethod(RedistributionMethod e) {
  if (flatbuffers::IsOutRange(e, RedistributionMethod::NONE, RedistributionMethod::EvenRedistribution)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRedistributionMethod()[index];
}

template<typename T> struct RedistributionMethodTraits {
  static const RedistributionMethod enum_value = RedistributionMethod::NONE;
};

template<> struct RedistributionMethodTraits<org::apache::arrow::ir::flatbuf::ExpressionRedistribution> {
  static const RedistributionMethod enum_value = RedistributionMethod::ExpressionRedistribution;
};

template<> struct RedistributionMethodTraits<org::apache::arrow::ir::flatbuf::EvenRedistribution> {
  static const RedistributionMethod enum_value = RedistributionMethod::EvenRedistribution;
};

bool VerifyRedistributionMethod(flatbuffers::Verifier &verifier, const void *obj, RedistributionMethod type);
bool VerifyRedistributionMethodVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum class CorrelateType : int8_t {
  REGULAR = 0,
  SEMI = 1,
  ANTI = 2,
  MIN = REGULAR,
  MAX = ANTI
};

inline const CorrelateType (&EnumValuesCorrelateType())[3] {
  static const CorrelateType values[] = {
    CorrelateType::REGULAR,
    CorrelateType::SEMI,
    CorrelateType::ANTI
  };
  return values;
}

inline const char * const *EnumNamesCorrelateType() {
  static const char * const names[4] = {
    "REGULAR",
    "SEMI",
    "ANTI",
    nullptr
  };
  return names;
}

inline const char *EnumNameCorrelateType(CorrelateType e) {
  if (flatbuffers::IsOutRange(e, CorrelateType::REGULAR, CorrelateType::ANTI)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCorrelateType()[index];
}

enum class JoinType : int8_t {
  INNER = 0,
  LEFT = 1,
  RIGHT = 2,
  OUTER = 3,
  MIN = INNER,
  MAX = OUTER
};

inline const JoinType (&EnumValuesJoinType())[4] {
  static const JoinType values[] = {
    JoinType::INNER,
    JoinType::LEFT,
    JoinType::RIGHT,
    JoinType::OUTER
  };
  return values;
}

inline const char * const *EnumNamesJoinType() {
  static const char * const names[5] = {
    "INNER",
    "LEFT",
    "RIGHT",
    "OUTER",
    nullptr
  };
  return names;
}

inline const char *EnumNameJoinType(JoinType e) {
  if (flatbuffers::IsOutRange(e, JoinType::INNER, JoinType::OUTER)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesJoinType()[index];
}

enum class SetOpType : int8_t {
  MINUS = 0,
  UNION_ALL = 1,
  UNION_DISTINCT = 2,
  INTERSECTION = 3,
  MIN = MINUS,
  MAX = INTERSECTION
};

inline const SetOpType (&EnumValuesSetOpType())[4] {
  static const SetOpType values[] = {
    SetOpType::MINUS,
    SetOpType::UNION_ALL,
    SetOpType::UNION_DISTINCT,
    SetOpType::INTERSECTION
  };
  return values;
}

inline const char * const *EnumNamesSetOpType() {
  static const char * const names[5] = {
    "MINUS",
    "UNION_ALL",
    "UNION_DISTINCT",
    "INTERSECTION",
    nullptr
  };
  return names;
}

inline const char *EnumNameSetOpType(SetOpType e) {
  if (flatbuffers::IsOutRange(e, SetOpType::MINUS, SetOpType::INTERSECTION)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSetOpType()[index];
}

enum class RelValue : uint8_t {
  NONE = 0,
  AggRel = 1,
  CorrelateRel = 2,
  SortRel = 3,
  FetchRel = 4,
  ProjectRel = 5,
  FilterRel = 6,
  WriteRel = 7,
  ReadRel = 8,
  JoinRel = 9,
  RedistributeRel = 10,
  SetRel = 11,
  SetRelAlt = 12,
  MIN = NONE,
  MAX = SetRelAlt
};

inline const RelValue (&EnumValuesRelValue())[13] {
  static const RelValue values[] = {
    RelValue::NONE,
    RelValue::AggRel,
    RelValue::CorrelateRel,
    RelValue::SortRel,
    RelValue::FetchRel,
    RelValue::ProjectRel,
    RelValue::FilterRel,
    RelValue::WriteRel,
    RelValue::ReadRel,
    RelValue::JoinRel,
    RelValue::RedistributeRel,
    RelValue::SetRel,
    RelValue::SetRelAlt
  };
  return values;
}

inline const char * const *EnumNamesRelValue() {
  static const char * const names[14] = {
    "NONE",
    "AggRel",
    "CorrelateRel",
    "SortRel",
    "FetchRel",
    "ProjectRel",
    "FilterRel",
    "WriteRel",
    "ReadRel",
    "JoinRel",
    "RedistributeRel",
    "SetRel",
    "SetRelAlt",
    nullptr
  };
  return names;
}

inline const char *EnumNameRelValue(RelValue e) {
  if (flatbuffers::IsOutRange(e, RelValue::NONE, RelValue::SetRelAlt)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRelValue()[index];
}

template<typename T> struct RelValueTraits {
  static const RelValue enum_value = RelValue::NONE;
};

template<> struct RelValueTraits<org::apache::arrow::ir::flatbuf::AggRel> {
  static const RelValue enum_value = RelValue::AggRel;
};

template<> struct RelValueTraits<org::apache::arrow::ir::flatbuf::CorrelateRel> {
  static const RelValue enum_value = RelValue::CorrelateRel;
};

template<> struct RelValueTraits<org::apache::arrow::ir::flatbuf::SortRel> {
  static const RelValue enum_value = RelValue::SortRel;
};

template<> struct RelValueTraits<org::apache::arrow::ir::flatbuf::FetchRel> {
  static const RelValue enum_value = RelValue::FetchRel;
};

template<> struct RelValueTraits<org::apache::arrow::ir::flatbuf::ProjectRel> {
  static const RelValue enum_value = RelValue::ProjectRel;
};

template<> struct RelValueTraits<org::apache::arrow::ir::flatbuf::FilterRel> {
  static const RelValue enum_value = RelValue::FilterRel;
};

template<> struct RelValueTraits<org::apache::arrow::ir::flatbuf::WriteRel> {
  static const RelValue enum_value = RelValue::WriteRel;
};

template<> struct RelValueTraits<org::apache::arrow::ir::flatbuf::ReadRel> {
  static const RelValue enum_value = RelValue::ReadRel;
};

template<> struct RelValueTraits<org::apache::arrow::ir::flatbuf::JoinRel> {
  static const RelValue enum_value = RelValue::JoinRel;
};

template<> struct RelValueTraits<org::apache::arrow::ir::flatbuf::RedistributeRel> {
  static const RelValue enum_value = RelValue::RedistributeRel;
};

template<> struct RelValueTraits<org::apache::arrow::ir::flatbuf::SetRel> {
  static const RelValue enum_value = RelValue::SetRel;
};

template<> struct RelValueTraits<org::apache::arrow::ir::flatbuf::SetRelAlt> {
  static const RelValue enum_value = RelValue::SetRelAlt;
};

bool VerifyRelValue(flatbuffers::Verifier &verifier, const void *obj, RelValue type);
bool VerifyRelValueVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct Remap FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RemapBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OUTPUT_MAPPING = 4
  };
  const flatbuffers::Vector<uint32_t> *output_mapping() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_OUTPUT_MAPPING);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_OUTPUT_MAPPING) &&
           verifier.VerifyVector(output_mapping()) &&
           verifier.EndTable();
  }
};

struct RemapBuilder {
  typedef Remap Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_output_mapping(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> output_mapping) {
    fbb_.AddOffset(Remap::VT_OUTPUT_MAPPING, output_mapping);
  }
  explicit RemapBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RemapBuilder &operator=(const RemapBuilder &);
  flatbuffers::Offset<Remap> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Remap>(end);
    return o;
  }
};

inline flatbuffers::Offset<Remap> CreateRemap(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> output_mapping = 0) {
  RemapBuilder builder_(_fbb);
  builder_.add_output_mapping(output_mapping);
  return builder_.Finish();
}

inline flatbuffers::Offset<Remap> CreateRemapDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint32_t> *output_mapping = nullptr) {
  auto output_mapping__ = output_mapping ? _fbb.CreateVector<uint32_t>(*output_mapping) : 0;
  return org::apache::arrow::ir::flatbuf::CreateRemap(
      _fbb,
      output_mapping__);
}

struct Direct FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DirectBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct DirectBuilder {
  typedef Direct Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit DirectBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DirectBuilder &operator=(const DirectBuilder &);
  flatbuffers::Offset<Direct> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Direct>(end);
    return o;
  }
};

inline flatbuffers::Offset<Direct> CreateDirect(
    flatbuffers::FlatBufferBuilder &_fbb) {
  DirectBuilder builder_(_fbb);
  return builder_.Finish();
}

struct RelCommon FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RelCommonBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EMIT_TYPE = 4,
    VT_EMIT = 6,
    VT_HINTS = 8,
    VT_CONSTRAINT = 10
  };
  org::apache::arrow::ir::flatbuf::Emit emit_type() const {
    return static_cast<org::apache::arrow::ir::flatbuf::Emit>(GetField<uint8_t>(VT_EMIT_TYPE, 0));
  }
  const void *emit() const {
    return GetPointer<const void *>(VT_EMIT);
  }
  template<typename T> const T *emit_as() const;
  const org::apache::arrow::ir::flatbuf::Remap *emit_as_Remap() const {
    return emit_type() == org::apache::arrow::ir::flatbuf::Emit::Remap ? static_cast<const org::apache::arrow::ir::flatbuf::Remap *>(emit()) : nullptr;
  }
  const org::apache::arrow::ir::flatbuf::Direct *emit_as_Direct() const {
    return emit_type() == org::apache::arrow::ir::flatbuf::Emit::Direct ? static_cast<const org::apache::arrow::ir::flatbuf::Direct *>(emit()) : nullptr;
  }
  const org::apache::arrow::ir::flatbuf::Hints *hints() const {
    return GetPointer<const org::apache::arrow::ir::flatbuf::Hints *>(VT_HINTS);
  }
  const org::apache::arrow::ir::flatbuf::RuntimeConstraint *constraint() const {
    return GetPointer<const org::apache::arrow::ir::flatbuf::RuntimeConstraint *>(VT_CONSTRAINT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_EMIT_TYPE) &&
           VerifyOffset(verifier, VT_EMIT) &&
           VerifyEmit(verifier, emit(), emit_type()) &&
           VerifyOffset(verifier, VT_HINTS) &&
           verifier.VerifyTable(hints()) &&
           VerifyOffset(verifier, VT_CONSTRAINT) &&
           verifier.VerifyTable(constraint()) &&
           verifier.EndTable();
  }
};

template<> inline const org::apache::arrow::ir::flatbuf::Remap *RelCommon::emit_as<org::apache::arrow::ir::flatbuf::Remap>() const {
  return emit_as_Remap();
}

template<> inline const org::apache::arrow::ir::flatbuf::Direct *RelCommon::emit_as<org::apache::arrow::ir::flatbuf::Direct>() const {
  return emit_as_Direct();
}

struct RelCommonBuilder {
  typedef RelCommon Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_emit_type(org::apache::arrow::ir::flatbuf::Emit emit_type) {
    fbb_.AddElement<uint8_t>(RelCommon::VT_EMIT_TYPE, static_cast<uint8_t>(emit_type), 0);
  }
  void add_emit(flatbuffers::Offset<void> emit) {
    fbb_.AddOffset(RelCommon::VT_EMIT, emit);
  }
  void add_hints(flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Hints> hints) {
    fbb_.AddOffset(RelCommon::VT_HINTS, hints);
  }
  void add_constraint(flatbuffers::Offset<org::apache::arrow::ir::flatbuf::RuntimeConstraint> constraint) {
    fbb_.AddOffset(RelCommon::VT_CONSTRAINT, constraint);
  }
  explicit RelCommonBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RelCommonBuilder &operator=(const RelCommonBuilder &);
  flatbuffers::Offset<RelCommon> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RelCommon>(end);
    return o;
  }
};

inline flatbuffers::Offset<RelCommon> CreateRelCommon(
    flatbuffers::FlatBufferBuilder &_fbb,
    org::apache::arrow::ir::flatbuf::Emit emit_type = org::apache::arrow::ir::flatbuf::Emit::NONE,
    flatbuffers::Offset<void> emit = 0,
    flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Hints> hints = 0,
    flatbuffers::Offset<org::apache::arrow::ir::flatbuf::RuntimeConstraint> constraint = 0) {
  RelCommonBuilder builder_(_fbb);
  builder_.add_constraint(constraint);
  builder_.add_hints(hints);
  builder_.add_emit(emit);
  builder_.add_emit_type(emit_type);
  return builder_.Finish();
}

struct Hints FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HintsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HINTS = 4,
    VT_STATS = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::HintKeyValue>> *hints() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::HintKeyValue>> *>(VT_HINTS);
  }
  const org::apache::arrow::ir::flatbuf::Stats *stats() const {
    return GetPointer<const org::apache::arrow::ir::flatbuf::Stats *>(VT_STATS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_HINTS) &&
           verifier.VerifyVector(hints()) &&
           verifier.VerifyVectorOfTables(hints()) &&
           VerifyOffset(verifier, VT_STATS) &&
           verifier.VerifyTable(stats()) &&
           verifier.EndTable();
  }
};

struct HintsBuilder {
  typedef Hints Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_hints(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::HintKeyValue>>> hints) {
    fbb_.AddOffset(Hints::VT_HINTS, hints);
  }
  void add_stats(flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Stats> stats) {
    fbb_.AddOffset(Hints::VT_STATS, stats);
  }
  explicit HintsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HintsBuilder &operator=(const HintsBuilder &);
  flatbuffers::Offset<Hints> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Hints>(end);
    return o;
  }
};

inline flatbuffers::Offset<Hints> CreateHints(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::HintKeyValue>>> hints = 0,
    flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Stats> stats = 0) {
  HintsBuilder builder_(_fbb);
  builder_.add_stats(stats);
  builder_.add_hints(hints);
  return builder_.Finish();
}

inline flatbuffers::Offset<Hints> CreateHintsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::HintKeyValue>> *hints = nullptr,
    flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Stats> stats = 0) {
  auto hints__ = hints ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::HintKeyValue>>(*hints) : 0;
  return org::apache::arrow::ir::flatbuf::CreateHints(
      _fbb,
      hints__,
      stats);
}

struct RuntimeConstraint FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RuntimeConstraintBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct RuntimeConstraintBuilder {
  typedef RuntimeConstraint Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit RuntimeConstraintBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RuntimeConstraintBuilder &operator=(const RuntimeConstraintBuilder &);
  flatbuffers::Offset<RuntimeConstraint> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RuntimeConstraint>(end);
    return o;
  }
};

inline flatbuffers::Offset<RuntimeConstraint> CreateRuntimeConstraint(
    flatbuffers::FlatBufferBuilder &_fbb) {
  RuntimeConstraintBuilder builder_(_fbb);
  return builder_.Finish();
}

struct HintKeyValue FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HintKeyValueBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_VALUE = 6
  };
  const flatbuffers::String *key() const {
    return GetPointer<const flatbuffers::String *>(VT_KEY);
  }
  const flatbuffers::Vector<uint8_t> *value() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.EndTable();
  }
};

struct HintKeyValueBuilder {
  typedef HintKeyValue Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_key(flatbuffers::Offset<flatbuffers::String> key) {
    fbb_.AddOffset(HintKeyValue::VT_KEY, key);
  }
  void add_value(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> value) {
    fbb_.AddOffset(HintKeyValue::VT_VALUE, value);
  }
  explicit HintKeyValueBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HintKeyValueBuilder &operator=(const HintKeyValueBuilder &);
  flatbuffers::Offset<HintKeyValue> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HintKeyValue>(end);
    return o;
  }
};

inline flatbuffers::Offset<HintKeyValue> CreateHintKeyValue(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> key = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> value = 0) {
  HintKeyValueBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key(key);
  return builder_.Finish();
}

inline flatbuffers::Offset<HintKeyValue> CreateHintKeyValueDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr,
    const std::vector<uint8_t> *value = nullptr) {
  auto key__ = key ? _fbb.CreateString(key) : 0;
  auto value__ = value ? _fbb.CreateVector<uint8_t>(*value) : 0;
  return org::apache::arrow::ir::flatbuf::CreateHintKeyValue(
      _fbb,
      key__,
      value__);
}

struct Stats FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StatsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ROW_COUNT = 4,
    VT_RECORD_SIZE = 6
  };
  double row_count() const {
    return GetField<double>(VT_ROW_COUNT, 0.0);
  }
  double record_size() const {
    return GetField<double>(VT_RECORD_SIZE, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_ROW_COUNT) &&
           VerifyField<double>(verifier, VT_RECORD_SIZE) &&
           verifier.EndTable();
  }
};

struct StatsBuilder {
  typedef Stats Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_row_count(double row_count) {
    fbb_.AddElement<double>(Stats::VT_ROW_COUNT, row_count, 0.0);
  }
  void add_record_size(double record_size) {
    fbb_.AddElement<double>(Stats::VT_RECORD_SIZE, record_size, 0.0);
  }
  explicit StatsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StatsBuilder &operator=(const StatsBuilder &);
  flatbuffers::Offset<Stats> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Stats>(end);
    return o;
  }
};

inline flatbuffers::Offset<Stats> CreateStats(
    flatbuffers::FlatBufferBuilder &_fbb,
    double row_count = 0.0,
    double record_size = 0.0) {
  StatsBuilder builder_(_fbb);
  builder_.add_record_size(record_size);
  builder_.add_row_count(row_count);
  return builder_.Finish();
}

struct EvenRedistribution FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EvenRedistributionBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct EvenRedistributionBuilder {
  typedef EvenRedistribution Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit EvenRedistributionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EvenRedistributionBuilder &operator=(const EvenRedistributionBuilder &);
  flatbuffers::Offset<EvenRedistribution> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EvenRedistribution>(end);
    return o;
  }
};

inline flatbuffers::Offset<EvenRedistribution> CreateEvenRedistribution(
    flatbuffers::FlatBufferBuilder &_fbb) {
  EvenRedistributionBuilder builder_(_fbb);
  return builder_.Finish();
}

struct RedistributeRel FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RedistributeRelBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMMON = 4,
    VT_REDISTRIBUTION_TYPE = 6,
    VT_REDISTRIBUTION = 8
  };
  const org::apache::arrow::ir::flatbuf::RelCommon *common() const {
    return GetPointer<const org::apache::arrow::ir::flatbuf::RelCommon *>(VT_COMMON);
  }
  org::apache::arrow::ir::flatbuf::RedistributionMethod redistribution_type() const {
    return static_cast<org::apache::arrow::ir::flatbuf::RedistributionMethod>(GetField<uint8_t>(VT_REDISTRIBUTION_TYPE, 0));
  }
  const void *redistribution() const {
    return GetPointer<const void *>(VT_REDISTRIBUTION);
  }
  template<typename T> const T *redistribution_as() const;
  const org::apache::arrow::ir::flatbuf::ExpressionRedistribution *redistribution_as_ExpressionRedistribution() const {
    return redistribution_type() == org::apache::arrow::ir::flatbuf::RedistributionMethod::ExpressionRedistribution ? static_cast<const org::apache::arrow::ir::flatbuf::ExpressionRedistribution *>(redistribution()) : nullptr;
  }
  const org::apache::arrow::ir::flatbuf::EvenRedistribution *redistribution_as_EvenRedistribution() const {
    return redistribution_type() == org::apache::arrow::ir::flatbuf::RedistributionMethod::EvenRedistribution ? static_cast<const org::apache::arrow::ir::flatbuf::EvenRedistribution *>(redistribution()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COMMON) &&
           verifier.VerifyTable(common()) &&
           VerifyField<uint8_t>(verifier, VT_REDISTRIBUTION_TYPE) &&
           VerifyOffset(verifier, VT_REDISTRIBUTION) &&
           VerifyRedistributionMethod(verifier, redistribution(), redistribution_type()) &&
           verifier.EndTable();
  }
};

template<> inline const org::apache::arrow::ir::flatbuf::ExpressionRedistribution *RedistributeRel::redistribution_as<org::apache::arrow::ir::flatbuf::ExpressionRedistribution>() const {
  return redistribution_as_ExpressionRedistribution();
}

template<> inline const org::apache::arrow::ir::flatbuf::EvenRedistribution *RedistributeRel::redistribution_as<org::apache::arrow::ir::flatbuf::EvenRedistribution>() const {
  return redistribution_as_EvenRedistribution();
}

struct RedistributeRelBuilder {
  typedef RedistributeRel Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_common(flatbuffers::Offset<org::apache::arrow::ir::flatbuf::RelCommon> common) {
    fbb_.AddOffset(RedistributeRel::VT_COMMON, common);
  }
  void add_redistribution_type(org::apache::arrow::ir::flatbuf::RedistributionMethod redistribution_type) {
    fbb_.AddElement<uint8_t>(RedistributeRel::VT_REDISTRIBUTION_TYPE, static_cast<uint8_t>(redistribution_type), 0);
  }
  void add_redistribution(flatbuffers::Offset<void> redistribution) {
    fbb_.AddOffset(RedistributeRel::VT_REDISTRIBUTION, redistribution);
  }
  explicit RedistributeRelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RedistributeRelBuilder &operator=(const RedistributeRelBuilder &);
  flatbuffers::Offset<RedistributeRel> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RedistributeRel>(end);
    return o;
  }
};

inline flatbuffers::Offset<RedistributeRel> CreateRedistributeRel(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::ir::flatbuf::RelCommon> common = 0,
    org::apache::arrow::ir::flatbuf::RedistributionMethod redistribution_type = org::apache::arrow::ir::flatbuf::RedistributionMethod::NONE,
    flatbuffers::Offset<void> redistribution = 0) {
  RedistributeRelBuilder builder_(_fbb);
  builder_.add_redistribution(redistribution);
  builder_.add_common(common);
  builder_.add_redistribution_type(redistribution_type);
  return builder_.Finish();
}

struct ExpressionRedistribution FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ExpressionRedistributionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BUCKET_COUNT = 4,
    VT_DISTRIBUTION_EXPRESSION = 6,
    VT_SORT_FIELDS = 8
  };
  int32_t bucket_count() const {
    return GetField<int32_t>(VT_BUCKET_COUNT, 0);
  }
  const org::apache::arrow::ir::flatbuf::Rex *distribution_expression() const {
    return GetPointer<const org::apache::arrow::ir::flatbuf::Rex *>(VT_DISTRIBUTION_EXPRESSION);
  }
  const flatbuffers::Vector<uint32_t> *sort_fields() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_SORT_FIELDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_BUCKET_COUNT) &&
           VerifyOffset(verifier, VT_DISTRIBUTION_EXPRESSION) &&
           verifier.VerifyTable(distribution_expression()) &&
           VerifyOffset(verifier, VT_SORT_FIELDS) &&
           verifier.VerifyVector(sort_fields()) &&
           verifier.EndTable();
  }
};

struct ExpressionRedistributionBuilder {
  typedef ExpressionRedistribution Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_bucket_count(int32_t bucket_count) {
    fbb_.AddElement<int32_t>(ExpressionRedistribution::VT_BUCKET_COUNT, bucket_count, 0);
  }
  void add_distribution_expression(flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Rex> distribution_expression) {
    fbb_.AddOffset(ExpressionRedistribution::VT_DISTRIBUTION_EXPRESSION, distribution_expression);
  }
  void add_sort_fields(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> sort_fields) {
    fbb_.AddOffset(ExpressionRedistribution::VT_SORT_FIELDS, sort_fields);
  }
  explicit ExpressionRedistributionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ExpressionRedistributionBuilder &operator=(const ExpressionRedistributionBuilder &);
  flatbuffers::Offset<ExpressionRedistribution> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ExpressionRedistribution>(end);
    return o;
  }
};

inline flatbuffers::Offset<ExpressionRedistribution> CreateExpressionRedistribution(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t bucket_count = 0,
    flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Rex> distribution_expression = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> sort_fields = 0) {
  ExpressionRedistributionBuilder builder_(_fbb);
  builder_.add_sort_fields(sort_fields);
  builder_.add_distribution_expression(distribution_expression);
  builder_.add_bucket_count(bucket_count);
  return builder_.Finish();
}

inline flatbuffers::Offset<ExpressionRedistribution> CreateExpressionRedistributionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t bucket_count = 0,
    flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Rex> distribution_expression = 0,
    const std::vector<uint32_t> *sort_fields = nullptr) {
  auto sort_fields__ = sort_fields ? _fbb.CreateVector<uint32_t>(*sort_fields) : 0;
  return org::apache::arrow::ir::flatbuf::CreateExpressionRedistribution(
      _fbb,
      bucket_count,
      distribution_expression,
      sort_fields__);
}

struct Grouping FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GroupingBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FIELD = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Rex>> *field() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Rex>> *>(VT_FIELD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FIELD) &&
           verifier.VerifyVector(field()) &&
           verifier.VerifyVectorOfTables(field()) &&
           verifier.EndTable();
  }
};

struct GroupingBuilder {
  typedef Grouping Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_field(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Rex>>> field) {
    fbb_.AddOffset(Grouping::VT_FIELD, field);
  }
  explicit GroupingBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GroupingBuilder &operator=(const GroupingBuilder &);
  flatbuffers::Offset<Grouping> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Grouping>(end);
    return o;
  }
};

inline flatbuffers::Offset<Grouping> CreateGrouping(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Rex>>> field = 0) {
  GroupingBuilder builder_(_fbb);
  builder_.add_field(field);
  return builder_.Finish();
}

inline flatbuffers::Offset<Grouping> CreateGroupingDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Rex>> *field = nullptr) {
  auto field__ = field ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Rex>>(*field) : 0;
  return org::apache::arrow::ir::flatbuf::CreateGrouping(
      _fbb,
      field__);
}

struct AggRel FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AggRelBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMMON = 4,
    VT_INPUT = 6,
    VT_GROUPINGS = 8,
    VT_MEASURES = 10
  };
  const org::apache::arrow::ir::flatbuf::RelCommon *common() const {
    return GetPointer<const org::apache::arrow::ir::flatbuf::RelCommon *>(VT_COMMON);
  }
  const org::apache::arrow::ir::flatbuf::Rel *input() const {
    return GetPointer<const org::apache::arrow::ir::flatbuf::Rel *>(VT_INPUT);
  }
  const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Grouping>> *groupings() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Grouping>> *>(VT_GROUPINGS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Rex>> *measures() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Rex>> *>(VT_MEASURES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COMMON) &&
           verifier.VerifyTable(common()) &&
           VerifyOffset(verifier, VT_INPUT) &&
           verifier.VerifyTable(input()) &&
           VerifyOffset(verifier, VT_GROUPINGS) &&
           verifier.VerifyVector(groupings()) &&
           verifier.VerifyVectorOfTables(groupings()) &&
           VerifyOffset(verifier, VT_MEASURES) &&
           verifier.VerifyVector(measures()) &&
           verifier.VerifyVectorOfTables(measures()) &&
           verifier.EndTable();
  }
};

struct AggRelBuilder {
  typedef AggRel Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_common(flatbuffers::Offset<org::apache::arrow::ir::flatbuf::RelCommon> common) {
    fbb_.AddOffset(AggRel::VT_COMMON, common);
  }
  void add_input(flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Rel> input) {
    fbb_.AddOffset(AggRel::VT_INPUT, input);
  }
  void add_groupings(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Grouping>>> groupings) {
    fbb_.AddOffset(AggRel::VT_GROUPINGS, groupings);
  }
  void add_measures(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Rex>>> measures) {
    fbb_.AddOffset(AggRel::VT_MEASURES, measures);
  }
  explicit AggRelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AggRelBuilder &operator=(const AggRelBuilder &);
  flatbuffers::Offset<AggRel> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AggRel>(end);
    return o;
  }
};

inline flatbuffers::Offset<AggRel> CreateAggRel(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::ir::flatbuf::RelCommon> common = 0,
    flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Rel> input = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Grouping>>> groupings = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Rex>>> measures = 0) {
  AggRelBuilder builder_(_fbb);
  builder_.add_measures(measures);
  builder_.add_groupings(groupings);
  builder_.add_input(input);
  builder_.add_common(common);
  return builder_.Finish();
}

inline flatbuffers::Offset<AggRel> CreateAggRelDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::ir::flatbuf::RelCommon> common = 0,
    flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Rel> input = 0,
    const std::vector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Grouping>> *groupings = nullptr,
    const std::vector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Rex>> *measures = nullptr) {
  auto groupings__ = groupings ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Grouping>>(*groupings) : 0;
  auto measures__ = measures ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Rex>>(*measures) : 0;
  return org::apache::arrow::ir::flatbuf::CreateAggRel(
      _fbb,
      common,
      input,
      groupings__,
      measures__);
}

struct CorrelateRel FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CorrelateRelBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMMON = 4,
    VT_TYPE = 6,
    VT_LEFT = 8,
    VT_RIGHT = 10,
    VT_EXPRESSION = 12
  };
  const org::apache::arrow::ir::flatbuf::RelCommon *common() const {
    return GetPointer<const org::apache::arrow::ir::flatbuf::RelCommon *>(VT_COMMON);
  }
  org::apache::arrow::ir::flatbuf::CorrelateType type() const {
    return static_cast<org::apache::arrow::ir::flatbuf::CorrelateType>(GetField<int8_t>(VT_TYPE, 0));
  }
  const org::apache::arrow::ir::flatbuf::Rel *left() const {
    return GetPointer<const org::apache::arrow::ir::flatbuf::Rel *>(VT_LEFT);
  }
  const org::apache::arrow::ir::flatbuf::Rel *right() const {
    return GetPointer<const org::apache::arrow::ir::flatbuf::Rel *>(VT_RIGHT);
  }
  const org::apache::arrow::ir::flatbuf::Rex *expression() const {
    return GetPointer<const org::apache::arrow::ir::flatbuf::Rex *>(VT_EXPRESSION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COMMON) &&
           verifier.VerifyTable(common()) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_LEFT) &&
           verifier.VerifyTable(left()) &&
           VerifyOffset(verifier, VT_RIGHT) &&
           verifier.VerifyTable(right()) &&
           VerifyOffset(verifier, VT_EXPRESSION) &&
           verifier.VerifyTable(expression()) &&
           verifier.EndTable();
  }
};

struct CorrelateRelBuilder {
  typedef CorrelateRel Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_common(flatbuffers::Offset<org::apache::arrow::ir::flatbuf::RelCommon> common) {
    fbb_.AddOffset(CorrelateRel::VT_COMMON, common);
  }
  void add_type(org::apache::arrow::ir::flatbuf::CorrelateType type) {
    fbb_.AddElement<int8_t>(CorrelateRel::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_left(flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Rel> left) {
    fbb_.AddOffset(CorrelateRel::VT_LEFT, left);
  }
  void add_right(flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Rel> right) {
    fbb_.AddOffset(CorrelateRel::VT_RIGHT, right);
  }
  void add_expression(flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Rex> expression) {
    fbb_.AddOffset(CorrelateRel::VT_EXPRESSION, expression);
  }
  explicit CorrelateRelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CorrelateRelBuilder &operator=(const CorrelateRelBuilder &);
  flatbuffers::Offset<CorrelateRel> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CorrelateRel>(end);
    return o;
  }
};

inline flatbuffers::Offset<CorrelateRel> CreateCorrelateRel(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::ir::flatbuf::RelCommon> common = 0,
    org::apache::arrow::ir::flatbuf::CorrelateType type = org::apache::arrow::ir::flatbuf::CorrelateType::REGULAR,
    flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Rel> left = 0,
    flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Rel> right = 0,
    flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Rex> expression = 0) {
  CorrelateRelBuilder builder_(_fbb);
  builder_.add_expression(expression);
  builder_.add_right(right);
  builder_.add_left(left);
  builder_.add_common(common);
  builder_.add_type(type);
  return builder_.Finish();
}

struct JoinRel FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef JoinRelBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMMON = 4,
    VT_JOIN_TYPE = 6,
    VT_LEFT = 8,
    VT_RIGHT = 10,
    VT_CONDITION = 12
  };
  const org::apache::arrow::ir::flatbuf::RelCommon *common() const {
    return GetPointer<const org::apache::arrow::ir::flatbuf::RelCommon *>(VT_COMMON);
  }
  org::apache::arrow::ir::flatbuf::JoinType join_type() const {
    return static_cast<org::apache::arrow::ir::flatbuf::JoinType>(GetField<int8_t>(VT_JOIN_TYPE, 0));
  }
  const org::apache::arrow::ir::flatbuf::Rel *left() const {
    return GetPointer<const org::apache::arrow::ir::flatbuf::Rel *>(VT_LEFT);
  }
  const org::apache::arrow::ir::flatbuf::Rel *right() const {
    return GetPointer<const org::apache::arrow::ir::flatbuf::Rel *>(VT_RIGHT);
  }
  const org::apache::arrow::ir::flatbuf::Rex *condition() const {
    return GetPointer<const org::apache::arrow::ir::flatbuf::Rex *>(VT_CONDITION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COMMON) &&
           verifier.VerifyTable(common()) &&
           VerifyField<int8_t>(verifier, VT_JOIN_TYPE) &&
           VerifyOffset(verifier, VT_LEFT) &&
           verifier.VerifyTable(left()) &&
           VerifyOffset(verifier, VT_RIGHT) &&
           verifier.VerifyTable(right()) &&
           VerifyOffset(verifier, VT_CONDITION) &&
           verifier.VerifyTable(condition()) &&
           verifier.EndTable();
  }
};

struct JoinRelBuilder {
  typedef JoinRel Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_common(flatbuffers::Offset<org::apache::arrow::ir::flatbuf::RelCommon> common) {
    fbb_.AddOffset(JoinRel::VT_COMMON, common);
  }
  void add_join_type(org::apache::arrow::ir::flatbuf::JoinType join_type) {
    fbb_.AddElement<int8_t>(JoinRel::VT_JOIN_TYPE, static_cast<int8_t>(join_type), 0);
  }
  void add_left(flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Rel> left) {
    fbb_.AddOffset(JoinRel::VT_LEFT, left);
  }
  void add_right(flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Rel> right) {
    fbb_.AddOffset(JoinRel::VT_RIGHT, right);
  }
  void add_condition(flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Rex> condition) {
    fbb_.AddOffset(JoinRel::VT_CONDITION, condition);
  }
  explicit JoinRelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  JoinRelBuilder &operator=(const JoinRelBuilder &);
  flatbuffers::Offset<JoinRel> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<JoinRel>(end);
    return o;
  }
};

inline flatbuffers::Offset<JoinRel> CreateJoinRel(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::ir::flatbuf::RelCommon> common = 0,
    org::apache::arrow::ir::flatbuf::JoinType join_type = org::apache::arrow::ir::flatbuf::JoinType::INNER,
    flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Rel> left = 0,
    flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Rel> right = 0,
    flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Rex> condition = 0) {
  JoinRelBuilder builder_(_fbb);
  builder_.add_condition(condition);
  builder_.add_right(right);
  builder_.add_left(left);
  builder_.add_common(common);
  builder_.add_join_type(join_type);
  return builder_.Finish();
}

struct SetRel FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SetRelBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INPUTS = 4,
    VT_SET_OP_TYPE = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Rel>> *inputs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Rel>> *>(VT_INPUTS);
  }
  org::apache::arrow::ir::flatbuf::SetOpType set_op_type() const {
    return static_cast<org::apache::arrow::ir::flatbuf::SetOpType>(GetField<int8_t>(VT_SET_OP_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           verifier.VerifyVectorOfTables(inputs()) &&
           VerifyField<int8_t>(verifier, VT_SET_OP_TYPE) &&
           verifier.EndTable();
  }
};

struct SetRelBuilder {
  typedef SetRel Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_inputs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Rel>>> inputs) {
    fbb_.AddOffset(SetRel::VT_INPUTS, inputs);
  }
  void add_set_op_type(org::apache::arrow::ir::flatbuf::SetOpType set_op_type) {
    fbb_.AddElement<int8_t>(SetRel::VT_SET_OP_TYPE, static_cast<int8_t>(set_op_type), 0);
  }
  explicit SetRelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SetRelBuilder &operator=(const SetRelBuilder &);
  flatbuffers::Offset<SetRel> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SetRel>(end);
    return o;
  }
};

inline flatbuffers::Offset<SetRel> CreateSetRel(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Rel>>> inputs = 0,
    org::apache::arrow::ir::flatbuf::SetOpType set_op_type = org::apache::arrow::ir::flatbuf::SetOpType::MINUS) {
  SetRelBuilder builder_(_fbb);
  builder_.add_inputs(inputs);
  builder_.add_set_op_type(set_op_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<SetRel> CreateSetRelDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Rel>> *inputs = nullptr,
    org::apache::arrow::ir::flatbuf::SetOpType set_op_type = org::apache::arrow::ir::flatbuf::SetOpType::MINUS) {
  auto inputs__ = inputs ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Rel>>(*inputs) : 0;
  return org::apache::arrow::ir::flatbuf::CreateSetRel(
      _fbb,
      inputs__,
      set_op_type);
}

struct SetRelAlt FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SetRelAltBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LEFT = 4,
    VT_RIGHT = 6,
    VT_SET_OP_TYPE = 8
  };
  const org::apache::arrow::ir::flatbuf::Rel *left() const {
    return GetPointer<const org::apache::arrow::ir::flatbuf::Rel *>(VT_LEFT);
  }
  const org::apache::arrow::ir::flatbuf::Rel *right() const {
    return GetPointer<const org::apache::arrow::ir::flatbuf::Rel *>(VT_RIGHT);
  }
  org::apache::arrow::ir::flatbuf::SetOpType set_op_type() const {
    return static_cast<org::apache::arrow::ir::flatbuf::SetOpType>(GetField<int8_t>(VT_SET_OP_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LEFT) &&
           verifier.VerifyTable(left()) &&
           VerifyOffset(verifier, VT_RIGHT) &&
           verifier.VerifyTable(right()) &&
           VerifyField<int8_t>(verifier, VT_SET_OP_TYPE) &&
           verifier.EndTable();
  }
};

struct SetRelAltBuilder {
  typedef SetRelAlt Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_left(flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Rel> left) {
    fbb_.AddOffset(SetRelAlt::VT_LEFT, left);
  }
  void add_right(flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Rel> right) {
    fbb_.AddOffset(SetRelAlt::VT_RIGHT, right);
  }
  void add_set_op_type(org::apache::arrow::ir::flatbuf::SetOpType set_op_type) {
    fbb_.AddElement<int8_t>(SetRelAlt::VT_SET_OP_TYPE, static_cast<int8_t>(set_op_type), 0);
  }
  explicit SetRelAltBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SetRelAltBuilder &operator=(const SetRelAltBuilder &);
  flatbuffers::Offset<SetRelAlt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SetRelAlt>(end);
    return o;
  }
};

inline flatbuffers::Offset<SetRelAlt> CreateSetRelAlt(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Rel> left = 0,
    flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Rel> right = 0,
    org::apache::arrow::ir::flatbuf::SetOpType set_op_type = org::apache::arrow::ir::flatbuf::SetOpType::MINUS) {
  SetRelAltBuilder builder_(_fbb);
  builder_.add_right(right);
  builder_.add_left(left);
  builder_.add_set_op_type(set_op_type);
  return builder_.Finish();
}

struct SortRel FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SortRelBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMMON = 4,
    VT_INPUT = 6,
    VT_SORT = 8
  };
  const org::apache::arrow::ir::flatbuf::RelCommon *common() const {
    return GetPointer<const org::apache::arrow::ir::flatbuf::RelCommon *>(VT_COMMON);
  }
  const org::apache::arrow::ir::flatbuf::Rel *input() const {
    return GetPointer<const org::apache::arrow::ir::flatbuf::Rel *>(VT_INPUT);
  }
  const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::SortField>> *sort() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::SortField>> *>(VT_SORT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COMMON) &&
           verifier.VerifyTable(common()) &&
           VerifyOffset(verifier, VT_INPUT) &&
           verifier.VerifyTable(input()) &&
           VerifyOffset(verifier, VT_SORT) &&
           verifier.VerifyVector(sort()) &&
           verifier.VerifyVectorOfTables(sort()) &&
           verifier.EndTable();
  }
};

struct SortRelBuilder {
  typedef SortRel Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_common(flatbuffers::Offset<org::apache::arrow::ir::flatbuf::RelCommon> common) {
    fbb_.AddOffset(SortRel::VT_COMMON, common);
  }
  void add_input(flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Rel> input) {
    fbb_.AddOffset(SortRel::VT_INPUT, input);
  }
  void add_sort(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::SortField>>> sort) {
    fbb_.AddOffset(SortRel::VT_SORT, sort);
  }
  explicit SortRelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SortRelBuilder &operator=(const SortRelBuilder &);
  flatbuffers::Offset<SortRel> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SortRel>(end);
    return o;
  }
};

inline flatbuffers::Offset<SortRel> CreateSortRel(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::ir::flatbuf::RelCommon> common = 0,
    flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Rel> input = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::SortField>>> sort = 0) {
  SortRelBuilder builder_(_fbb);
  builder_.add_sort(sort);
  builder_.add_input(input);
  builder_.add_common(common);
  return builder_.Finish();
}

inline flatbuffers::Offset<SortRel> CreateSortRelDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::ir::flatbuf::RelCommon> common = 0,
    flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Rel> input = 0,
    const std::vector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::SortField>> *sort = nullptr) {
  auto sort__ = sort ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::SortField>>(*sort) : 0;
  return org::apache::arrow::ir::flatbuf::CreateSortRel(
      _fbb,
      common,
      input,
      sort__);
}

struct ProjectRel FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ProjectRelBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMMON = 4,
    VT_INPUT = 6,
    VT_EXPRS = 8
  };
  const org::apache::arrow::ir::flatbuf::RelCommon *common() const {
    return GetPointer<const org::apache::arrow::ir::flatbuf::RelCommon *>(VT_COMMON);
  }
  const org::apache::arrow::ir::flatbuf::Rel *input() const {
    return GetPointer<const org::apache::arrow::ir::flatbuf::Rel *>(VT_INPUT);
  }
  const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Rex>> *exprs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Rex>> *>(VT_EXPRS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COMMON) &&
           verifier.VerifyTable(common()) &&
           VerifyOffset(verifier, VT_INPUT) &&
           verifier.VerifyTable(input()) &&
           VerifyOffset(verifier, VT_EXPRS) &&
           verifier.VerifyVector(exprs()) &&
           verifier.VerifyVectorOfTables(exprs()) &&
           verifier.EndTable();
  }
};

struct ProjectRelBuilder {
  typedef ProjectRel Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_common(flatbuffers::Offset<org::apache::arrow::ir::flatbuf::RelCommon> common) {
    fbb_.AddOffset(ProjectRel::VT_COMMON, common);
  }
  void add_input(flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Rel> input) {
    fbb_.AddOffset(ProjectRel::VT_INPUT, input);
  }
  void add_exprs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Rex>>> exprs) {
    fbb_.AddOffset(ProjectRel::VT_EXPRS, exprs);
  }
  explicit ProjectRelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ProjectRelBuilder &operator=(const ProjectRelBuilder &);
  flatbuffers::Offset<ProjectRel> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ProjectRel>(end);
    return o;
  }
};

inline flatbuffers::Offset<ProjectRel> CreateProjectRel(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::ir::flatbuf::RelCommon> common = 0,
    flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Rel> input = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Rex>>> exprs = 0) {
  ProjectRelBuilder builder_(_fbb);
  builder_.add_exprs(exprs);
  builder_.add_input(input);
  builder_.add_common(common);
  return builder_.Finish();
}

inline flatbuffers::Offset<ProjectRel> CreateProjectRelDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::ir::flatbuf::RelCommon> common = 0,
    flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Rel> input = 0,
    const std::vector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Rex>> *exprs = nullptr) {
  auto exprs__ = exprs ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Rex>>(*exprs) : 0;
  return org::apache::arrow::ir::flatbuf::CreateProjectRel(
      _fbb,
      common,
      input,
      exprs__);
}

struct FetchRel FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FetchRelBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMMON = 4,
    VT_INPUT = 6,
    VT_START = 8,
    VT_END = 10
  };
  const org::apache::arrow::ir::flatbuf::RelCommon *common() const {
    return GetPointer<const org::apache::arrow::ir::flatbuf::RelCommon *>(VT_COMMON);
  }
  const org::apache::arrow::ir::flatbuf::Rel *input() const {
    return GetPointer<const org::apache::arrow::ir::flatbuf::Rel *>(VT_INPUT);
  }
  int64_t start() const {
    return GetField<int64_t>(VT_START, 0);
  }
  int64_t end() const {
    return GetField<int64_t>(VT_END, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COMMON) &&
           verifier.VerifyTable(common()) &&
           VerifyOffset(verifier, VT_INPUT) &&
           verifier.VerifyTable(input()) &&
           VerifyField<int64_t>(verifier, VT_START) &&
           VerifyField<int64_t>(verifier, VT_END) &&
           verifier.EndTable();
  }
};

struct FetchRelBuilder {
  typedef FetchRel Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_common(flatbuffers::Offset<org::apache::arrow::ir::flatbuf::RelCommon> common) {
    fbb_.AddOffset(FetchRel::VT_COMMON, common);
  }
  void add_input(flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Rel> input) {
    fbb_.AddOffset(FetchRel::VT_INPUT, input);
  }
  void add_start(int64_t start) {
    fbb_.AddElement<int64_t>(FetchRel::VT_START, start, 0);
  }
  void add_end(int64_t end) {
    fbb_.AddElement<int64_t>(FetchRel::VT_END, end, 0);
  }
  explicit FetchRelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FetchRelBuilder &operator=(const FetchRelBuilder &);
  flatbuffers::Offset<FetchRel> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FetchRel>(end);
    return o;
  }
};

inline flatbuffers::Offset<FetchRel> CreateFetchRel(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::ir::flatbuf::RelCommon> common = 0,
    flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Rel> input = 0,
    int64_t start = 0,
    int64_t end = 0) {
  FetchRelBuilder builder_(_fbb);
  builder_.add_end(end);
  builder_.add_start(start);
  builder_.add_input(input);
  builder_.add_common(common);
  return builder_.Finish();
}

struct FilterRel FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FilterRelBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMMON = 4,
    VT_INPUT = 6,
    VT_CONDITION = 8
  };
  const org::apache::arrow::ir::flatbuf::RelCommon *common() const {
    return GetPointer<const org::apache::arrow::ir::flatbuf::RelCommon *>(VT_COMMON);
  }
  const org::apache::arrow::ir::flatbuf::Rel *input() const {
    return GetPointer<const org::apache::arrow::ir::flatbuf::Rel *>(VT_INPUT);
  }
  const org::apache::arrow::ir::flatbuf::Rex *condition() const {
    return GetPointer<const org::apache::arrow::ir::flatbuf::Rex *>(VT_CONDITION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COMMON) &&
           verifier.VerifyTable(common()) &&
           VerifyOffset(verifier, VT_INPUT) &&
           verifier.VerifyTable(input()) &&
           VerifyOffset(verifier, VT_CONDITION) &&
           verifier.VerifyTable(condition()) &&
           verifier.EndTable();
  }
};

struct FilterRelBuilder {
  typedef FilterRel Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_common(flatbuffers::Offset<org::apache::arrow::ir::flatbuf::RelCommon> common) {
    fbb_.AddOffset(FilterRel::VT_COMMON, common);
  }
  void add_input(flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Rel> input) {
    fbb_.AddOffset(FilterRel::VT_INPUT, input);
  }
  void add_condition(flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Rex> condition) {
    fbb_.AddOffset(FilterRel::VT_CONDITION, condition);
  }
  explicit FilterRelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FilterRelBuilder &operator=(const FilterRelBuilder &);
  flatbuffers::Offset<FilterRel> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FilterRel>(end);
    return o;
  }
};

inline flatbuffers::Offset<FilterRel> CreateFilterRel(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::ir::flatbuf::RelCommon> common = 0,
    flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Rel> input = 0,
    flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Rex> condition = 0) {
  FilterRelBuilder builder_(_fbb);
  builder_.add_condition(condition);
  builder_.add_input(input);
  builder_.add_common(common);
  return builder_.Finish();
}

struct ReadRel FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReadRelBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMMON = 4,
    VT_CONFIG = 6
  };
  const org::apache::arrow::ir::flatbuf::RelCommon *common() const {
    return GetPointer<const org::apache::arrow::ir::flatbuf::RelCommon *>(VT_COMMON);
  }
  const flatbuffers::Vector<int8_t> *config() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_CONFIG);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COMMON) &&
           verifier.VerifyTable(common()) &&
           VerifyOffset(verifier, VT_CONFIG) &&
           verifier.VerifyVector(config()) &&
           verifier.EndTable();
  }
};

struct ReadRelBuilder {
  typedef ReadRel Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_common(flatbuffers::Offset<org::apache::arrow::ir::flatbuf::RelCommon> common) {
    fbb_.AddOffset(ReadRel::VT_COMMON, common);
  }
  void add_config(flatbuffers::Offset<flatbuffers::Vector<int8_t>> config) {
    fbb_.AddOffset(ReadRel::VT_CONFIG, config);
  }
  explicit ReadRelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReadRelBuilder &operator=(const ReadRelBuilder &);
  flatbuffers::Offset<ReadRel> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReadRel>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReadRel> CreateReadRel(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::ir::flatbuf::RelCommon> common = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> config = 0) {
  ReadRelBuilder builder_(_fbb);
  builder_.add_config(config);
  builder_.add_common(common);
  return builder_.Finish();
}

inline flatbuffers::Offset<ReadRel> CreateReadRelDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::ir::flatbuf::RelCommon> common = 0,
    const std::vector<int8_t> *config = nullptr) {
  auto config__ = config ? _fbb.CreateVector<int8_t>(*config) : 0;
  return org::apache::arrow::ir::flatbuf::CreateReadRel(
      _fbb,
      common,
      config__);
}

struct LiteralRel FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LiteralRelBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMMON = 4,
    VT_VALUES = 6
  };
  const org::apache::arrow::ir::flatbuf::RelCommon *common() const {
    return GetPointer<const org::apache::arrow::ir::flatbuf::RelCommon *>(VT_COMMON);
  }
  const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::StructLiteral>> *values() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::StructLiteral>> *>(VT_VALUES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COMMON) &&
           verifier.VerifyTable(common()) &&
           VerifyOffset(verifier, VT_VALUES) &&
           verifier.VerifyVector(values()) &&
           verifier.VerifyVectorOfTables(values()) &&
           verifier.EndTable();
  }
};

struct LiteralRelBuilder {
  typedef LiteralRel Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_common(flatbuffers::Offset<org::apache::arrow::ir::flatbuf::RelCommon> common) {
    fbb_.AddOffset(LiteralRel::VT_COMMON, common);
  }
  void add_values(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::StructLiteral>>> values) {
    fbb_.AddOffset(LiteralRel::VT_VALUES, values);
  }
  explicit LiteralRelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiteralRelBuilder &operator=(const LiteralRelBuilder &);
  flatbuffers::Offset<LiteralRel> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiteralRel>(end);
    return o;
  }
};

inline flatbuffers::Offset<LiteralRel> CreateLiteralRel(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::ir::flatbuf::RelCommon> common = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::StructLiteral>>> values = 0) {
  LiteralRelBuilder builder_(_fbb);
  builder_.add_values(values);
  builder_.add_common(common);
  return builder_.Finish();
}

inline flatbuffers::Offset<LiteralRel> CreateLiteralRelDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::ir::flatbuf::RelCommon> common = 0,
    const std::vector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::StructLiteral>> *values = nullptr) {
  auto values__ = values ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::StructLiteral>>(*values) : 0;
  return org::apache::arrow::ir::flatbuf::CreateLiteralRel(
      _fbb,
      common,
      values__);
}

struct WriteRel FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef WriteRelBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMMON = 4,
    VT_SCHEMA = 6,
    VT_INPUT = 8,
    VT_CONFIG = 10
  };
  const org::apache::arrow::ir::flatbuf::RelCommon *common() const {
    return GetPointer<const org::apache::arrow::ir::flatbuf::RelCommon *>(VT_COMMON);
  }
  const org::apache::arrow::flatbuf::Schema *schema() const {
    return GetPointer<const org::apache::arrow::flatbuf::Schema *>(VT_SCHEMA);
  }
  const org::apache::arrow::ir::flatbuf::Rel *input() const {
    return GetPointer<const org::apache::arrow::ir::flatbuf::Rel *>(VT_INPUT);
  }
  const flatbuffers::Vector<int8_t> *config() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_CONFIG);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COMMON) &&
           verifier.VerifyTable(common()) &&
           VerifyOffset(verifier, VT_SCHEMA) &&
           verifier.VerifyTable(schema()) &&
           VerifyOffset(verifier, VT_INPUT) &&
           verifier.VerifyTable(input()) &&
           VerifyOffset(verifier, VT_CONFIG) &&
           verifier.VerifyVector(config()) &&
           verifier.EndTable();
  }
};

struct WriteRelBuilder {
  typedef WriteRel Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_common(flatbuffers::Offset<org::apache::arrow::ir::flatbuf::RelCommon> common) {
    fbb_.AddOffset(WriteRel::VT_COMMON, common);
  }
  void add_schema(flatbuffers::Offset<org::apache::arrow::flatbuf::Schema> schema) {
    fbb_.AddOffset(WriteRel::VT_SCHEMA, schema);
  }
  void add_input(flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Rel> input) {
    fbb_.AddOffset(WriteRel::VT_INPUT, input);
  }
  void add_config(flatbuffers::Offset<flatbuffers::Vector<int8_t>> config) {
    fbb_.AddOffset(WriteRel::VT_CONFIG, config);
  }
  explicit WriteRelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WriteRelBuilder &operator=(const WriteRelBuilder &);
  flatbuffers::Offset<WriteRel> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WriteRel>(end);
    return o;
  }
};

inline flatbuffers::Offset<WriteRel> CreateWriteRel(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::ir::flatbuf::RelCommon> common = 0,
    flatbuffers::Offset<org::apache::arrow::flatbuf::Schema> schema = 0,
    flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Rel> input = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> config = 0) {
  WriteRelBuilder builder_(_fbb);
  builder_.add_config(config);
  builder_.add_input(input);
  builder_.add_schema(schema);
  builder_.add_common(common);
  return builder_.Finish();
}

inline flatbuffers::Offset<WriteRel> CreateWriteRelDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::ir::flatbuf::RelCommon> common = 0,
    flatbuffers::Offset<org::apache::arrow::flatbuf::Schema> schema = 0,
    flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Rel> input = 0,
    const std::vector<int8_t> *config = nullptr) {
  auto config__ = config ? _fbb.CreateVector<int8_t>(*config) : 0;
  return org::apache::arrow::ir::flatbuf::CreateWriteRel(
      _fbb,
      common,
      schema,
      input,
      config__);
}

struct Rel FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RelBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE_TYPE = 4,
    VT_VALUE = 6
  };
  org::apache::arrow::ir::flatbuf::RelValue value_type() const {
    return static_cast<org::apache::arrow::ir::flatbuf::RelValue>(GetField<uint8_t>(VT_VALUE_TYPE, 0));
  }
  const void *value() const {
    return GetPointer<const void *>(VT_VALUE);
  }
  template<typename T> const T *value_as() const;
  const org::apache::arrow::ir::flatbuf::AggRel *value_as_AggRel() const {
    return value_type() == org::apache::arrow::ir::flatbuf::RelValue::AggRel ? static_cast<const org::apache::arrow::ir::flatbuf::AggRel *>(value()) : nullptr;
  }
  const org::apache::arrow::ir::flatbuf::CorrelateRel *value_as_CorrelateRel() const {
    return value_type() == org::apache::arrow::ir::flatbuf::RelValue::CorrelateRel ? static_cast<const org::apache::arrow::ir::flatbuf::CorrelateRel *>(value()) : nullptr;
  }
  const org::apache::arrow::ir::flatbuf::SortRel *value_as_SortRel() const {
    return value_type() == org::apache::arrow::ir::flatbuf::RelValue::SortRel ? static_cast<const org::apache::arrow::ir::flatbuf::SortRel *>(value()) : nullptr;
  }
  const org::apache::arrow::ir::flatbuf::FetchRel *value_as_FetchRel() const {
    return value_type() == org::apache::arrow::ir::flatbuf::RelValue::FetchRel ? static_cast<const org::apache::arrow::ir::flatbuf::FetchRel *>(value()) : nullptr;
  }
  const org::apache::arrow::ir::flatbuf::ProjectRel *value_as_ProjectRel() const {
    return value_type() == org::apache::arrow::ir::flatbuf::RelValue::ProjectRel ? static_cast<const org::apache::arrow::ir::flatbuf::ProjectRel *>(value()) : nullptr;
  }
  const org::apache::arrow::ir::flatbuf::FilterRel *value_as_FilterRel() const {
    return value_type() == org::apache::arrow::ir::flatbuf::RelValue::FilterRel ? static_cast<const org::apache::arrow::ir::flatbuf::FilterRel *>(value()) : nullptr;
  }
  const org::apache::arrow::ir::flatbuf::WriteRel *value_as_WriteRel() const {
    return value_type() == org::apache::arrow::ir::flatbuf::RelValue::WriteRel ? static_cast<const org::apache::arrow::ir::flatbuf::WriteRel *>(value()) : nullptr;
  }
  const org::apache::arrow::ir::flatbuf::ReadRel *value_as_ReadRel() const {
    return value_type() == org::apache::arrow::ir::flatbuf::RelValue::ReadRel ? static_cast<const org::apache::arrow::ir::flatbuf::ReadRel *>(value()) : nullptr;
  }
  const org::apache::arrow::ir::flatbuf::JoinRel *value_as_JoinRel() const {
    return value_type() == org::apache::arrow::ir::flatbuf::RelValue::JoinRel ? static_cast<const org::apache::arrow::ir::flatbuf::JoinRel *>(value()) : nullptr;
  }
  const org::apache::arrow::ir::flatbuf::RedistributeRel *value_as_RedistributeRel() const {
    return value_type() == org::apache::arrow::ir::flatbuf::RelValue::RedistributeRel ? static_cast<const org::apache::arrow::ir::flatbuf::RedistributeRel *>(value()) : nullptr;
  }
  const org::apache::arrow::ir::flatbuf::SetRel *value_as_SetRel() const {
    return value_type() == org::apache::arrow::ir::flatbuf::RelValue::SetRel ? static_cast<const org::apache::arrow::ir::flatbuf::SetRel *>(value()) : nullptr;
  }
  const org::apache::arrow::ir::flatbuf::SetRelAlt *value_as_SetRelAlt() const {
    return value_type() == org::apache::arrow::ir::flatbuf::RelValue::SetRelAlt ? static_cast<const org::apache::arrow::ir::flatbuf::SetRelAlt *>(value()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VALUE_TYPE) &&
           VerifyOffset(verifier, VT_VALUE) &&
           VerifyRelValue(verifier, value(), value_type()) &&
           verifier.EndTable();
  }
};

template<> inline const org::apache::arrow::ir::flatbuf::AggRel *Rel::value_as<org::apache::arrow::ir::flatbuf::AggRel>() const {
  return value_as_AggRel();
}

template<> inline const org::apache::arrow::ir::flatbuf::CorrelateRel *Rel::value_as<org::apache::arrow::ir::flatbuf::CorrelateRel>() const {
  return value_as_CorrelateRel();
}

template<> inline const org::apache::arrow::ir::flatbuf::SortRel *Rel::value_as<org::apache::arrow::ir::flatbuf::SortRel>() const {
  return value_as_SortRel();
}

template<> inline const org::apache::arrow::ir::flatbuf::FetchRel *Rel::value_as<org::apache::arrow::ir::flatbuf::FetchRel>() const {
  return value_as_FetchRel();
}

template<> inline const org::apache::arrow::ir::flatbuf::ProjectRel *Rel::value_as<org::apache::arrow::ir::flatbuf::ProjectRel>() const {
  return value_as_ProjectRel();
}

template<> inline const org::apache::arrow::ir::flatbuf::FilterRel *Rel::value_as<org::apache::arrow::ir::flatbuf::FilterRel>() const {
  return value_as_FilterRel();
}

template<> inline const org::apache::arrow::ir::flatbuf::WriteRel *Rel::value_as<org::apache::arrow::ir::flatbuf::WriteRel>() const {
  return value_as_WriteRel();
}

template<> inline const org::apache::arrow::ir::flatbuf::ReadRel *Rel::value_as<org::apache::arrow::ir::flatbuf::ReadRel>() const {
  return value_as_ReadRel();
}

template<> inline const org::apache::arrow::ir::flatbuf::JoinRel *Rel::value_as<org::apache::arrow::ir::flatbuf::JoinRel>() const {
  return value_as_JoinRel();
}

template<> inline const org::apache::arrow::ir::flatbuf::RedistributeRel *Rel::value_as<org::apache::arrow::ir::flatbuf::RedistributeRel>() const {
  return value_as_RedistributeRel();
}

template<> inline const org::apache::arrow::ir::flatbuf::SetRel *Rel::value_as<org::apache::arrow::ir::flatbuf::SetRel>() const {
  return value_as_SetRel();
}

template<> inline const org::apache::arrow::ir::flatbuf::SetRelAlt *Rel::value_as<org::apache::arrow::ir::flatbuf::SetRelAlt>() const {
  return value_as_SetRelAlt();
}

struct RelBuilder {
  typedef Rel Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value_type(org::apache::arrow::ir::flatbuf::RelValue value_type) {
    fbb_.AddElement<uint8_t>(Rel::VT_VALUE_TYPE, static_cast<uint8_t>(value_type), 0);
  }
  void add_value(flatbuffers::Offset<void> value) {
    fbb_.AddOffset(Rel::VT_VALUE, value);
  }
  explicit RelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RelBuilder &operator=(const RelBuilder &);
  flatbuffers::Offset<Rel> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Rel>(end);
    return o;
  }
};

inline flatbuffers::Offset<Rel> CreateRel(
    flatbuffers::FlatBufferBuilder &_fbb,
    org::apache::arrow::ir::flatbuf::RelValue value_type = org::apache::arrow::ir::flatbuf::RelValue::NONE,
    flatbuffers::Offset<void> value = 0) {
  RelBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_value_type(value_type);
  return builder_.Finish();
}

inline bool VerifyEmit(flatbuffers::Verifier &verifier, const void *obj, Emit type) {
  switch (type) {
    case Emit::NONE: {
      return true;
    }
    case Emit::Remap: {
      auto ptr = reinterpret_cast<const org::apache::arrow::ir::flatbuf::Remap *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Emit::Direct: {
      auto ptr = reinterpret_cast<const org::apache::arrow::ir::flatbuf::Direct *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyEmitVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyEmit(
        verifier,  values->Get(i), types->GetEnum<Emit>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyRedistributionMethod(flatbuffers::Verifier &verifier, const void *obj, RedistributionMethod type) {
  switch (type) {
    case RedistributionMethod::NONE: {
      return true;
    }
    case RedistributionMethod::ExpressionRedistribution: {
      auto ptr = reinterpret_cast<const org::apache::arrow::ir::flatbuf::ExpressionRedistribution *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RedistributionMethod::EvenRedistribution: {
      auto ptr = reinterpret_cast<const org::apache::arrow::ir::flatbuf::EvenRedistribution *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyRedistributionMethodVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyRedistributionMethod(
        verifier,  values->Get(i), types->GetEnum<RedistributionMethod>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyRelValue(flatbuffers::Verifier &verifier, const void *obj, RelValue type) {
  switch (type) {
    case RelValue::NONE: {
      return true;
    }
    case RelValue::AggRel: {
      auto ptr = reinterpret_cast<const org::apache::arrow::ir::flatbuf::AggRel *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RelValue::CorrelateRel: {
      auto ptr = reinterpret_cast<const org::apache::arrow::ir::flatbuf::CorrelateRel *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RelValue::SortRel: {
      auto ptr = reinterpret_cast<const org::apache::arrow::ir::flatbuf::SortRel *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RelValue::FetchRel: {
      auto ptr = reinterpret_cast<const org::apache::arrow::ir::flatbuf::FetchRel *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RelValue::ProjectRel: {
      auto ptr = reinterpret_cast<const org::apache::arrow::ir::flatbuf::ProjectRel *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RelValue::FilterRel: {
      auto ptr = reinterpret_cast<const org::apache::arrow::ir::flatbuf::FilterRel *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RelValue::WriteRel: {
      auto ptr = reinterpret_cast<const org::apache::arrow::ir::flatbuf::WriteRel *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RelValue::ReadRel: {
      auto ptr = reinterpret_cast<const org::apache::arrow::ir::flatbuf::ReadRel *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RelValue::JoinRel: {
      auto ptr = reinterpret_cast<const org::apache::arrow::ir::flatbuf::JoinRel *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RelValue::RedistributeRel: {
      auto ptr = reinterpret_cast<const org::apache::arrow::ir::flatbuf::RedistributeRel *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RelValue::SetRel: {
      auto ptr = reinterpret_cast<const org::apache::arrow::ir::flatbuf::SetRel *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RelValue::SetRelAlt: {
      auto ptr = reinterpret_cast<const org::apache::arrow::ir::flatbuf::SetRelAlt *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyRelValueVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyRelValue(
        verifier,  values->Get(i), types->GetEnum<RelValue>(i))) {
      return false;
    }
  }
  return true;
}

inline const org::apache::arrow::ir::flatbuf::Rel *GetRel(const void *buf) {
  return flatbuffers::GetRoot<org::apache::arrow::ir::flatbuf::Rel>(buf);
}

inline const org::apache::arrow::ir::flatbuf::Rel *GetSizePrefixedRel(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<org::apache::arrow::ir::flatbuf::Rel>(buf);
}

inline bool VerifyRelBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<org::apache::arrow::ir::flatbuf::Rel>(nullptr);
}

inline bool VerifySizePrefixedRelBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<org::apache::arrow::ir::flatbuf::Rel>(nullptr);
}

inline void FinishRelBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Rel> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedRelBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Rel> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace flatbuf
}  // namespace ir
}  // namespace arrow
}  // namespace apache
}  // namespace org

#endif  // FLATBUFFERS_GENERATED_IRRELATIONAL_ORG_APACHE_ARROW_IR_FLATBUF_H_
