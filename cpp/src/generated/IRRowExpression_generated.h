// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_IRROWEXPRESSION_ORG_APACHE_ARROW_IR_FLATBUF_H_
#define FLATBUFFERS_GENERATED_IRROWEXPRESSION_ORG_APACHE_ARROW_IR_FLATBUF_H_

#include "flatbuffers/flatbuffers.h"

#include "IRFunction_generated.h"
#include "IRLiteral_generated.h"
#include "Schema_generated.h"

namespace org {
namespace apache {
namespace arrow {
namespace ir {
namespace flatbuf {

struct RexFunction;
struct RexFunctionBuilder;

struct RexName;
struct RexNameBuilder;

struct RexMapKey;
struct RexMapKeyBuilder;

struct RexStructField;
struct RexStructFieldBuilder;

struct RexArrayPosition;
struct RexArrayPositionBuilder;

struct RexArrayItem;
struct RexArrayItemBuilder;

struct RexArraySlice;
struct RexArraySliceBuilder;

struct RexDereference;
struct RexDereferenceBuilder;

struct Preceding;
struct PrecedingBuilder;

struct Following;
struct FollowingBuilder;

struct CurrentRow;
struct CurrentRowBuilder;

struct SortField;
struct SortFieldBuilder;

struct RexWindowFunction;
struct RexWindowFunctionBuilder;

struct Rex;
struct RexBuilder;

enum class RexDereferenceElement : uint8_t {
  NONE = 0,
  RexStructField = 1,
  RexName = 2,
  RexArrayItem = 3,
  RexArraySlice = 4,
  MIN = NONE,
  MAX = RexArraySlice
};

inline const RexDereferenceElement (&EnumValuesRexDereferenceElement())[5] {
  static const RexDereferenceElement values[] = {
    RexDereferenceElement::NONE,
    RexDereferenceElement::RexStructField,
    RexDereferenceElement::RexName,
    RexDereferenceElement::RexArrayItem,
    RexDereferenceElement::RexArraySlice
  };
  return values;
}

inline const char * const *EnumNamesRexDereferenceElement() {
  static const char * const names[6] = {
    "NONE",
    "RexStructField",
    "RexName",
    "RexArrayItem",
    "RexArraySlice",
    nullptr
  };
  return names;
}

inline const char *EnumNameRexDereferenceElement(RexDereferenceElement e) {
  if (flatbuffers::IsOutRange(e, RexDereferenceElement::NONE, RexDereferenceElement::RexArraySlice)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRexDereferenceElement()[index];
}

template<typename T> struct RexDereferenceElementTraits {
  static const RexDereferenceElement enum_value = RexDereferenceElement::NONE;
};

template<> struct RexDereferenceElementTraits<org::apache::arrow::ir::flatbuf::RexStructField> {
  static const RexDereferenceElement enum_value = RexDereferenceElement::RexStructField;
};

template<> struct RexDereferenceElementTraits<org::apache::arrow::ir::flatbuf::RexName> {
  static const RexDereferenceElement enum_value = RexDereferenceElement::RexName;
};

template<> struct RexDereferenceElementTraits<org::apache::arrow::ir::flatbuf::RexArrayItem> {
  static const RexDereferenceElement enum_value = RexDereferenceElement::RexArrayItem;
};

template<> struct RexDereferenceElementTraits<org::apache::arrow::ir::flatbuf::RexArraySlice> {
  static const RexDereferenceElement enum_value = RexDereferenceElement::RexArraySlice;
};

bool VerifyRexDereferenceElement(flatbuffers::Verifier &verifier, const void *obj, RexDereferenceElement type);
bool VerifyRexDereferenceElementVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum class Bound : uint8_t {
  NONE = 0,
  Preceding = 1,
  Following = 2,
  CurrentRow = 3,
  MIN = NONE,
  MAX = CurrentRow
};

inline const Bound (&EnumValuesBound())[4] {
  static const Bound values[] = {
    Bound::NONE,
    Bound::Preceding,
    Bound::Following,
    Bound::CurrentRow
  };
  return values;
}

inline const char * const *EnumNamesBound() {
  static const char * const names[5] = {
    "NONE",
    "Preceding",
    "Following",
    "CurrentRow",
    nullptr
  };
  return names;
}

inline const char *EnumNameBound(Bound e) {
  if (flatbuffers::IsOutRange(e, Bound::NONE, Bound::CurrentRow)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesBound()[index];
}

template<typename T> struct BoundTraits {
  static const Bound enum_value = Bound::NONE;
};

template<> struct BoundTraits<org::apache::arrow::ir::flatbuf::Preceding> {
  static const Bound enum_value = Bound::Preceding;
};

template<> struct BoundTraits<org::apache::arrow::ir::flatbuf::Following> {
  static const Bound enum_value = Bound::Following;
};

template<> struct BoundTraits<org::apache::arrow::ir::flatbuf::CurrentRow> {
  static const Bound enum_value = Bound::CurrentRow;
};

bool VerifyBound(flatbuffers::Verifier &verifier, const void *obj, Bound type);
bool VerifyBoundVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum class SortType : int8_t {
  UNKNOWN = 0,
  ASC_NULLS_FIRST = 1,
  ASC_NULLS_LAST = 2,
  DESC_NULLS_FIRST = 3,
  DESC_NULLS_LAST = 4,
  CLUSTERED = 5,
  MIN = UNKNOWN,
  MAX = CLUSTERED
};

inline const SortType (&EnumValuesSortType())[6] {
  static const SortType values[] = {
    SortType::UNKNOWN,
    SortType::ASC_NULLS_FIRST,
    SortType::ASC_NULLS_LAST,
    SortType::DESC_NULLS_FIRST,
    SortType::DESC_NULLS_LAST,
    SortType::CLUSTERED
  };
  return values;
}

inline const char * const *EnumNamesSortType() {
  static const char * const names[7] = {
    "UNKNOWN",
    "ASC_NULLS_FIRST",
    "ASC_NULLS_LAST",
    "DESC_NULLS_FIRST",
    "DESC_NULLS_LAST",
    "CLUSTERED",
    nullptr
  };
  return names;
}

inline const char *EnumNameSortType(SortType e) {
  if (flatbuffers::IsOutRange(e, SortType::UNKNOWN, SortType::CLUSTERED)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSortType()[index];
}

enum class RexValue : uint8_t {
  NONE = 0,
  RexLiteral = 1,
  RexDereference = 2,
  RexFunction = 3,
  RexWindowFunction = 4,
  MIN = NONE,
  MAX = RexWindowFunction
};

inline const RexValue (&EnumValuesRexValue())[5] {
  static const RexValue values[] = {
    RexValue::NONE,
    RexValue::RexLiteral,
    RexValue::RexDereference,
    RexValue::RexFunction,
    RexValue::RexWindowFunction
  };
  return values;
}

inline const char * const *EnumNamesRexValue() {
  static const char * const names[6] = {
    "NONE",
    "RexLiteral",
    "RexDereference",
    "RexFunction",
    "RexWindowFunction",
    nullptr
  };
  return names;
}

inline const char *EnumNameRexValue(RexValue e) {
  if (flatbuffers::IsOutRange(e, RexValue::NONE, RexValue::RexWindowFunction)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRexValue()[index];
}

template<typename T> struct RexValueTraits {
  static const RexValue enum_value = RexValue::NONE;
};

template<> struct RexValueTraits<org::apache::arrow::ir::flatbuf::RexLiteral> {
  static const RexValue enum_value = RexValue::RexLiteral;
};

template<> struct RexValueTraits<org::apache::arrow::ir::flatbuf::RexDereference> {
  static const RexValue enum_value = RexValue::RexDereference;
};

template<> struct RexValueTraits<org::apache::arrow::ir::flatbuf::RexFunction> {
  static const RexValue enum_value = RexValue::RexFunction;
};

template<> struct RexValueTraits<org::apache::arrow::ir::flatbuf::RexWindowFunction> {
  static const RexValue enum_value = RexValue::RexWindowFunction;
};

bool VerifyRexValue(flatbuffers::Verifier &verifier, const void *obj, RexValue type);
bool VerifyRexValueVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct RexFunction FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RexFunctionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_ARGUMENTS = 6
  };
  const org::apache::arrow::ir::flatbuf::FunctionId *id() const {
    return GetPointer<const org::apache::arrow::ir::flatbuf::FunctionId *>(VT_ID);
  }
  const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Rex>> *arguments() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Rex>> *>(VT_ARGUMENTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           VerifyOffset(verifier, VT_ARGUMENTS) &&
           verifier.VerifyVector(arguments()) &&
           verifier.VerifyVectorOfTables(arguments()) &&
           verifier.EndTable();
  }
};

struct RexFunctionBuilder {
  typedef RexFunction Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<org::apache::arrow::ir::flatbuf::FunctionId> id) {
    fbb_.AddOffset(RexFunction::VT_ID, id);
  }
  void add_arguments(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Rex>>> arguments) {
    fbb_.AddOffset(RexFunction::VT_ARGUMENTS, arguments);
  }
  explicit RexFunctionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RexFunctionBuilder &operator=(const RexFunctionBuilder &);
  flatbuffers::Offset<RexFunction> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RexFunction>(end);
    return o;
  }
};

inline flatbuffers::Offset<RexFunction> CreateRexFunction(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::ir::flatbuf::FunctionId> id = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Rex>>> arguments = 0) {
  RexFunctionBuilder builder_(_fbb);
  builder_.add_arguments(arguments);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<RexFunction> CreateRexFunctionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::ir::flatbuf::FunctionId> id = 0,
    const std::vector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Rex>> *arguments = nullptr) {
  auto arguments__ = arguments ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Rex>>(*arguments) : 0;
  return org::apache::arrow::ir::flatbuf::CreateRexFunction(
      _fbb,
      id,
      arguments__);
}

struct RexName FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RexNameBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
};

struct RexNameBuilder {
  typedef RexName Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(RexName::VT_NAME, name);
  }
  explicit RexNameBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RexNameBuilder &operator=(const RexNameBuilder &);
  flatbuffers::Offset<RexName> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RexName>(end);
    return o;
  }
};

inline flatbuffers::Offset<RexName> CreateRexName(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  RexNameBuilder builder_(_fbb);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<RexName> CreateRexNameDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return org::apache::arrow::ir::flatbuf::CreateRexName(
      _fbb,
      name__);
}

struct RexMapKey FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RexMapKeyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
};

struct RexMapKeyBuilder {
  typedef RexMapKey Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(RexMapKey::VT_NAME, name);
  }
  explicit RexMapKeyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RexMapKeyBuilder &operator=(const RexMapKeyBuilder &);
  flatbuffers::Offset<RexMapKey> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RexMapKey>(end);
    return o;
  }
};

inline flatbuffers::Offset<RexMapKey> CreateRexMapKey(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  RexMapKeyBuilder builder_(_fbb);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<RexMapKey> CreateRexMapKeyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return org::apache::arrow::ir::flatbuf::CreateRexMapKey(
      _fbb,
      name__);
}

struct RexStructField FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RexStructFieldBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ORDINAL = 4
  };
  int32_t ordinal() const {
    return GetField<int32_t>(VT_ORDINAL, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ORDINAL) &&
           verifier.EndTable();
  }
};

struct RexStructFieldBuilder {
  typedef RexStructField Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ordinal(int32_t ordinal) {
    fbb_.AddElement<int32_t>(RexStructField::VT_ORDINAL, ordinal, 0);
  }
  explicit RexStructFieldBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RexStructFieldBuilder &operator=(const RexStructFieldBuilder &);
  flatbuffers::Offset<RexStructField> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RexStructField>(end);
    return o;
  }
};

inline flatbuffers::Offset<RexStructField> CreateRexStructField(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t ordinal = 0) {
  RexStructFieldBuilder builder_(_fbb);
  builder_.add_ordinal(ordinal);
  return builder_.Finish();
}

struct RexArrayPosition FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RexArrayPositionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POSITION = 4
  };
  int32_t position() const {
    return GetField<int32_t>(VT_POSITION, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_POSITION) &&
           verifier.EndTable();
  }
};

struct RexArrayPositionBuilder {
  typedef RexArrayPosition Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_position(int32_t position) {
    fbb_.AddElement<int32_t>(RexArrayPosition::VT_POSITION, position, 0);
  }
  explicit RexArrayPositionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RexArrayPositionBuilder &operator=(const RexArrayPositionBuilder &);
  flatbuffers::Offset<RexArrayPosition> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RexArrayPosition>(end);
    return o;
  }
};

inline flatbuffers::Offset<RexArrayPosition> CreateRexArrayPosition(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t position = 0) {
  RexArrayPositionBuilder builder_(_fbb);
  builder_.add_position(position);
  return builder_.Finish();
}

struct RexArrayItem FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RexArrayItemBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POSITION = 4
  };
  int64_t position() const {
    return GetField<int64_t>(VT_POSITION, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_POSITION) &&
           verifier.EndTable();
  }
};

struct RexArrayItemBuilder {
  typedef RexArrayItem Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_position(int64_t position) {
    fbb_.AddElement<int64_t>(RexArrayItem::VT_POSITION, position, 0);
  }
  explicit RexArrayItemBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RexArrayItemBuilder &operator=(const RexArrayItemBuilder &);
  flatbuffers::Offset<RexArrayItem> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RexArrayItem>(end);
    return o;
  }
};

inline flatbuffers::Offset<RexArrayItem> CreateRexArrayItem(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t position = 0) {
  RexArrayItemBuilder builder_(_fbb);
  builder_.add_position(position);
  return builder_.Finish();
}

struct RexArraySlice FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RexArraySliceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_START_INCLUSIVE = 4,
    VT_END_EXCLUSIVE = 6
  };
  int64_t start_inclusive() const {
    return GetField<int64_t>(VT_START_INCLUSIVE, 0);
  }
  int64_t end_exclusive() const {
    return GetField<int64_t>(VT_END_EXCLUSIVE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_START_INCLUSIVE) &&
           VerifyField<int64_t>(verifier, VT_END_EXCLUSIVE) &&
           verifier.EndTable();
  }
};

struct RexArraySliceBuilder {
  typedef RexArraySlice Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_start_inclusive(int64_t start_inclusive) {
    fbb_.AddElement<int64_t>(RexArraySlice::VT_START_INCLUSIVE, start_inclusive, 0);
  }
  void add_end_exclusive(int64_t end_exclusive) {
    fbb_.AddElement<int64_t>(RexArraySlice::VT_END_EXCLUSIVE, end_exclusive, 0);
  }
  explicit RexArraySliceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RexArraySliceBuilder &operator=(const RexArraySliceBuilder &);
  flatbuffers::Offset<RexArraySlice> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RexArraySlice>(end);
    return o;
  }
};

inline flatbuffers::Offset<RexArraySlice> CreateRexArraySlice(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t start_inclusive = 0,
    int64_t end_exclusive = 0) {
  RexArraySliceBuilder builder_(_fbb);
  builder_.add_end_exclusive(end_exclusive);
  builder_.add_start_inclusive(start_inclusive);
  return builder_.Finish();
}

struct RexDereference FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RexDereferenceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POSITIONS_TYPE = 4,
    VT_POSITIONS = 6
  };
  const flatbuffers::Vector<uint8_t> *positions_type() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_POSITIONS_TYPE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<void>> *positions() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<void>> *>(VT_POSITIONS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_POSITIONS_TYPE) &&
           verifier.VerifyVector(positions_type()) &&
           VerifyOffset(verifier, VT_POSITIONS) &&
           verifier.VerifyVector(positions()) &&
           VerifyRexDereferenceElementVector(verifier, positions(), positions_type()) &&
           verifier.EndTable();
  }
};

struct RexDereferenceBuilder {
  typedef RexDereference Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_positions_type(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> positions_type) {
    fbb_.AddOffset(RexDereference::VT_POSITIONS_TYPE, positions_type);
  }
  void add_positions(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> positions) {
    fbb_.AddOffset(RexDereference::VT_POSITIONS, positions);
  }
  explicit RexDereferenceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RexDereferenceBuilder &operator=(const RexDereferenceBuilder &);
  flatbuffers::Offset<RexDereference> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RexDereference>(end);
    return o;
  }
};

inline flatbuffers::Offset<RexDereference> CreateRexDereference(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> positions_type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> positions = 0) {
  RexDereferenceBuilder builder_(_fbb);
  builder_.add_positions(positions);
  builder_.add_positions_type(positions_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<RexDereference> CreateRexDereferenceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *positions_type = nullptr,
    const std::vector<flatbuffers::Offset<void>> *positions = nullptr) {
  auto positions_type__ = positions_type ? _fbb.CreateVector<uint8_t>(*positions_type) : 0;
  auto positions__ = positions ? _fbb.CreateVector<flatbuffers::Offset<void>>(*positions) : 0;
  return org::apache::arrow::ir::flatbuf::CreateRexDereference(
      _fbb,
      positions_type__,
      positions__);
}

struct Preceding FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PrecedingBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OFFSET = 4
  };
  /// TODO(cpcloud): Should this be an expression, to support that use case?
  ///                e.g., SELECT avg(x) OVER (RANGE BETWEEN num_days PRECEDING AND CURRENT ROW)
  int64_t offset() const {
    return GetField<int64_t>(VT_OFFSET, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OFFSET) &&
           verifier.EndTable();
  }
};

struct PrecedingBuilder {
  typedef Preceding Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_offset(int64_t offset) {
    fbb_.AddElement<int64_t>(Preceding::VT_OFFSET, offset, 0);
  }
  explicit PrecedingBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PrecedingBuilder &operator=(const PrecedingBuilder &);
  flatbuffers::Offset<Preceding> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Preceding>(end);
    return o;
  }
};

inline flatbuffers::Offset<Preceding> CreatePreceding(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t offset = 0) {
  PrecedingBuilder builder_(_fbb);
  builder_.add_offset(offset);
  return builder_.Finish();
}

struct Following FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FollowingBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OFFSET = 4
  };
  int64_t offset() const {
    return GetField<int64_t>(VT_OFFSET, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OFFSET) &&
           verifier.EndTable();
  }
};

struct FollowingBuilder {
  typedef Following Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_offset(int64_t offset) {
    fbb_.AddElement<int64_t>(Following::VT_OFFSET, offset, 0);
  }
  explicit FollowingBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FollowingBuilder &operator=(const FollowingBuilder &);
  flatbuffers::Offset<Following> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Following>(end);
    return o;
  }
};

inline flatbuffers::Offset<Following> CreateFollowing(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t offset = 0) {
  FollowingBuilder builder_(_fbb);
  builder_.add_offset(offset);
  return builder_.Finish();
}

struct CurrentRow FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CurrentRowBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct CurrentRowBuilder {
  typedef CurrentRow Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit CurrentRowBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CurrentRowBuilder &operator=(const CurrentRowBuilder &);
  flatbuffers::Offset<CurrentRow> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CurrentRow>(end);
    return o;
  }
};

inline flatbuffers::Offset<CurrentRow> CreateCurrentRow(
    flatbuffers::FlatBufferBuilder &_fbb) {
  CurrentRowBuilder builder_(_fbb);
  return builder_.Finish();
}

struct SortField FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SortFieldBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EXPR = 4,
    VT_TYPE = 6
  };
  const org::apache::arrow::ir::flatbuf::Rex *expr() const {
    return GetPointer<const org::apache::arrow::ir::flatbuf::Rex *>(VT_EXPR);
  }
  org::apache::arrow::ir::flatbuf::SortType type() const {
    return static_cast<org::apache::arrow::ir::flatbuf::SortType>(GetField<int8_t>(VT_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_EXPR) &&
           verifier.VerifyTable(expr()) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           verifier.EndTable();
  }
};

struct SortFieldBuilder {
  typedef SortField Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_expr(flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Rex> expr) {
    fbb_.AddOffset(SortField::VT_EXPR, expr);
  }
  void add_type(org::apache::arrow::ir::flatbuf::SortType type) {
    fbb_.AddElement<int8_t>(SortField::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  explicit SortFieldBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SortFieldBuilder &operator=(const SortFieldBuilder &);
  flatbuffers::Offset<SortField> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SortField>(end);
    return o;
  }
};

inline flatbuffers::Offset<SortField> CreateSortField(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Rex> expr = 0,
    org::apache::arrow::ir::flatbuf::SortType type = org::apache::arrow::ir::flatbuf::SortType::UNKNOWN) {
  SortFieldBuilder builder_(_fbb);
  builder_.add_expr(expr);
  builder_.add_type(type);
  return builder_.Finish();
}

struct RexWindowFunction FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RexWindowFunctionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PARTITIONS = 4,
    VT_SORTS = 6,
    VT_UPPER_BOUND_TYPE = 8,
    VT_UPPER_BOUND = 10,
    VT_LOWER_BOUND_TYPE = 12,
    VT_LOWER_BOUND = 14
  };
  const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Rex>> *partitions() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Rex>> *>(VT_PARTITIONS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::SortField>> *sorts() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::SortField>> *>(VT_SORTS);
  }
  org::apache::arrow::ir::flatbuf::Bound upper_bound_type() const {
    return static_cast<org::apache::arrow::ir::flatbuf::Bound>(GetField<uint8_t>(VT_UPPER_BOUND_TYPE, 0));
  }
  const void *upper_bound() const {
    return GetPointer<const void *>(VT_UPPER_BOUND);
  }
  template<typename T> const T *upper_bound_as() const;
  const org::apache::arrow::ir::flatbuf::Preceding *upper_bound_as_Preceding() const {
    return upper_bound_type() == org::apache::arrow::ir::flatbuf::Bound::Preceding ? static_cast<const org::apache::arrow::ir::flatbuf::Preceding *>(upper_bound()) : nullptr;
  }
  const org::apache::arrow::ir::flatbuf::Following *upper_bound_as_Following() const {
    return upper_bound_type() == org::apache::arrow::ir::flatbuf::Bound::Following ? static_cast<const org::apache::arrow::ir::flatbuf::Following *>(upper_bound()) : nullptr;
  }
  const org::apache::arrow::ir::flatbuf::CurrentRow *upper_bound_as_CurrentRow() const {
    return upper_bound_type() == org::apache::arrow::ir::flatbuf::Bound::CurrentRow ? static_cast<const org::apache::arrow::ir::flatbuf::CurrentRow *>(upper_bound()) : nullptr;
  }
  org::apache::arrow::ir::flatbuf::Bound lower_bound_type() const {
    return static_cast<org::apache::arrow::ir::flatbuf::Bound>(GetField<uint8_t>(VT_LOWER_BOUND_TYPE, 0));
  }
  const void *lower_bound() const {
    return GetPointer<const void *>(VT_LOWER_BOUND);
  }
  template<typename T> const T *lower_bound_as() const;
  const org::apache::arrow::ir::flatbuf::Preceding *lower_bound_as_Preceding() const {
    return lower_bound_type() == org::apache::arrow::ir::flatbuf::Bound::Preceding ? static_cast<const org::apache::arrow::ir::flatbuf::Preceding *>(lower_bound()) : nullptr;
  }
  const org::apache::arrow::ir::flatbuf::Following *lower_bound_as_Following() const {
    return lower_bound_type() == org::apache::arrow::ir::flatbuf::Bound::Following ? static_cast<const org::apache::arrow::ir::flatbuf::Following *>(lower_bound()) : nullptr;
  }
  const org::apache::arrow::ir::flatbuf::CurrentRow *lower_bound_as_CurrentRow() const {
    return lower_bound_type() == org::apache::arrow::ir::flatbuf::Bound::CurrentRow ? static_cast<const org::apache::arrow::ir::flatbuf::CurrentRow *>(lower_bound()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PARTITIONS) &&
           verifier.VerifyVector(partitions()) &&
           verifier.VerifyVectorOfTables(partitions()) &&
           VerifyOffset(verifier, VT_SORTS) &&
           verifier.VerifyVector(sorts()) &&
           verifier.VerifyVectorOfTables(sorts()) &&
           VerifyField<uint8_t>(verifier, VT_UPPER_BOUND_TYPE) &&
           VerifyOffset(verifier, VT_UPPER_BOUND) &&
           VerifyBound(verifier, upper_bound(), upper_bound_type()) &&
           VerifyField<uint8_t>(verifier, VT_LOWER_BOUND_TYPE) &&
           VerifyOffset(verifier, VT_LOWER_BOUND) &&
           VerifyBound(verifier, lower_bound(), lower_bound_type()) &&
           verifier.EndTable();
  }
};

template<> inline const org::apache::arrow::ir::flatbuf::Preceding *RexWindowFunction::upper_bound_as<org::apache::arrow::ir::flatbuf::Preceding>() const {
  return upper_bound_as_Preceding();
}

template<> inline const org::apache::arrow::ir::flatbuf::Following *RexWindowFunction::upper_bound_as<org::apache::arrow::ir::flatbuf::Following>() const {
  return upper_bound_as_Following();
}

template<> inline const org::apache::arrow::ir::flatbuf::CurrentRow *RexWindowFunction::upper_bound_as<org::apache::arrow::ir::flatbuf::CurrentRow>() const {
  return upper_bound_as_CurrentRow();
}

template<> inline const org::apache::arrow::ir::flatbuf::Preceding *RexWindowFunction::lower_bound_as<org::apache::arrow::ir::flatbuf::Preceding>() const {
  return lower_bound_as_Preceding();
}

template<> inline const org::apache::arrow::ir::flatbuf::Following *RexWindowFunction::lower_bound_as<org::apache::arrow::ir::flatbuf::Following>() const {
  return lower_bound_as_Following();
}

template<> inline const org::apache::arrow::ir::flatbuf::CurrentRow *RexWindowFunction::lower_bound_as<org::apache::arrow::ir::flatbuf::CurrentRow>() const {
  return lower_bound_as_CurrentRow();
}

struct RexWindowFunctionBuilder {
  typedef RexWindowFunction Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_partitions(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Rex>>> partitions) {
    fbb_.AddOffset(RexWindowFunction::VT_PARTITIONS, partitions);
  }
  void add_sorts(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::SortField>>> sorts) {
    fbb_.AddOffset(RexWindowFunction::VT_SORTS, sorts);
  }
  void add_upper_bound_type(org::apache::arrow::ir::flatbuf::Bound upper_bound_type) {
    fbb_.AddElement<uint8_t>(RexWindowFunction::VT_UPPER_BOUND_TYPE, static_cast<uint8_t>(upper_bound_type), 0);
  }
  void add_upper_bound(flatbuffers::Offset<void> upper_bound) {
    fbb_.AddOffset(RexWindowFunction::VT_UPPER_BOUND, upper_bound);
  }
  void add_lower_bound_type(org::apache::arrow::ir::flatbuf::Bound lower_bound_type) {
    fbb_.AddElement<uint8_t>(RexWindowFunction::VT_LOWER_BOUND_TYPE, static_cast<uint8_t>(lower_bound_type), 0);
  }
  void add_lower_bound(flatbuffers::Offset<void> lower_bound) {
    fbb_.AddOffset(RexWindowFunction::VT_LOWER_BOUND, lower_bound);
  }
  explicit RexWindowFunctionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RexWindowFunctionBuilder &operator=(const RexWindowFunctionBuilder &);
  flatbuffers::Offset<RexWindowFunction> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RexWindowFunction>(end);
    return o;
  }
};

inline flatbuffers::Offset<RexWindowFunction> CreateRexWindowFunction(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Rex>>> partitions = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::SortField>>> sorts = 0,
    org::apache::arrow::ir::flatbuf::Bound upper_bound_type = org::apache::arrow::ir::flatbuf::Bound::NONE,
    flatbuffers::Offset<void> upper_bound = 0,
    org::apache::arrow::ir::flatbuf::Bound lower_bound_type = org::apache::arrow::ir::flatbuf::Bound::NONE,
    flatbuffers::Offset<void> lower_bound = 0) {
  RexWindowFunctionBuilder builder_(_fbb);
  builder_.add_lower_bound(lower_bound);
  builder_.add_upper_bound(upper_bound);
  builder_.add_sorts(sorts);
  builder_.add_partitions(partitions);
  builder_.add_lower_bound_type(lower_bound_type);
  builder_.add_upper_bound_type(upper_bound_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<RexWindowFunction> CreateRexWindowFunctionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Rex>> *partitions = nullptr,
    const std::vector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::SortField>> *sorts = nullptr,
    org::apache::arrow::ir::flatbuf::Bound upper_bound_type = org::apache::arrow::ir::flatbuf::Bound::NONE,
    flatbuffers::Offset<void> upper_bound = 0,
    org::apache::arrow::ir::flatbuf::Bound lower_bound_type = org::apache::arrow::ir::flatbuf::Bound::NONE,
    flatbuffers::Offset<void> lower_bound = 0) {
  auto partitions__ = partitions ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Rex>>(*partitions) : 0;
  auto sorts__ = sorts ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::ir::flatbuf::SortField>>(*sorts) : 0;
  return org::apache::arrow::ir::flatbuf::CreateRexWindowFunction(
      _fbb,
      partitions__,
      sorts__,
      upper_bound_type,
      upper_bound,
      lower_bound_type,
      lower_bound);
}

struct Rex FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RexBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE_TYPE = 4,
    VT_VALUE = 6
  };
  org::apache::arrow::ir::flatbuf::RexValue value_type() const {
    return static_cast<org::apache::arrow::ir::flatbuf::RexValue>(GetField<uint8_t>(VT_VALUE_TYPE, 0));
  }
  const void *value() const {
    return GetPointer<const void *>(VT_VALUE);
  }
  template<typename T> const T *value_as() const;
  const org::apache::arrow::ir::flatbuf::RexLiteral *value_as_RexLiteral() const {
    return value_type() == org::apache::arrow::ir::flatbuf::RexValue::RexLiteral ? static_cast<const org::apache::arrow::ir::flatbuf::RexLiteral *>(value()) : nullptr;
  }
  const org::apache::arrow::ir::flatbuf::RexDereference *value_as_RexDereference() const {
    return value_type() == org::apache::arrow::ir::flatbuf::RexValue::RexDereference ? static_cast<const org::apache::arrow::ir::flatbuf::RexDereference *>(value()) : nullptr;
  }
  const org::apache::arrow::ir::flatbuf::RexFunction *value_as_RexFunction() const {
    return value_type() == org::apache::arrow::ir::flatbuf::RexValue::RexFunction ? static_cast<const org::apache::arrow::ir::flatbuf::RexFunction *>(value()) : nullptr;
  }
  const org::apache::arrow::ir::flatbuf::RexWindowFunction *value_as_RexWindowFunction() const {
    return value_type() == org::apache::arrow::ir::flatbuf::RexValue::RexWindowFunction ? static_cast<const org::apache::arrow::ir::flatbuf::RexWindowFunction *>(value()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VALUE_TYPE) &&
           VerifyOffset(verifier, VT_VALUE) &&
           VerifyRexValue(verifier, value(), value_type()) &&
           verifier.EndTable();
  }
};

template<> inline const org::apache::arrow::ir::flatbuf::RexLiteral *Rex::value_as<org::apache::arrow::ir::flatbuf::RexLiteral>() const {
  return value_as_RexLiteral();
}

template<> inline const org::apache::arrow::ir::flatbuf::RexDereference *Rex::value_as<org::apache::arrow::ir::flatbuf::RexDereference>() const {
  return value_as_RexDereference();
}

template<> inline const org::apache::arrow::ir::flatbuf::RexFunction *Rex::value_as<org::apache::arrow::ir::flatbuf::RexFunction>() const {
  return value_as_RexFunction();
}

template<> inline const org::apache::arrow::ir::flatbuf::RexWindowFunction *Rex::value_as<org::apache::arrow::ir::flatbuf::RexWindowFunction>() const {
  return value_as_RexWindowFunction();
}

struct RexBuilder {
  typedef Rex Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value_type(org::apache::arrow::ir::flatbuf::RexValue value_type) {
    fbb_.AddElement<uint8_t>(Rex::VT_VALUE_TYPE, static_cast<uint8_t>(value_type), 0);
  }
  void add_value(flatbuffers::Offset<void> value) {
    fbb_.AddOffset(Rex::VT_VALUE, value);
  }
  explicit RexBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RexBuilder &operator=(const RexBuilder &);
  flatbuffers::Offset<Rex> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Rex>(end);
    return o;
  }
};

inline flatbuffers::Offset<Rex> CreateRex(
    flatbuffers::FlatBufferBuilder &_fbb,
    org::apache::arrow::ir::flatbuf::RexValue value_type = org::apache::arrow::ir::flatbuf::RexValue::NONE,
    flatbuffers::Offset<void> value = 0) {
  RexBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_value_type(value_type);
  return builder_.Finish();
}

inline bool VerifyRexDereferenceElement(flatbuffers::Verifier &verifier, const void *obj, RexDereferenceElement type) {
  switch (type) {
    case RexDereferenceElement::NONE: {
      return true;
    }
    case RexDereferenceElement::RexStructField: {
      auto ptr = reinterpret_cast<const org::apache::arrow::ir::flatbuf::RexStructField *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RexDereferenceElement::RexName: {
      auto ptr = reinterpret_cast<const org::apache::arrow::ir::flatbuf::RexName *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RexDereferenceElement::RexArrayItem: {
      auto ptr = reinterpret_cast<const org::apache::arrow::ir::flatbuf::RexArrayItem *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RexDereferenceElement::RexArraySlice: {
      auto ptr = reinterpret_cast<const org::apache::arrow::ir::flatbuf::RexArraySlice *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyRexDereferenceElementVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyRexDereferenceElement(
        verifier,  values->Get(i), types->GetEnum<RexDereferenceElement>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyBound(flatbuffers::Verifier &verifier, const void *obj, Bound type) {
  switch (type) {
    case Bound::NONE: {
      return true;
    }
    case Bound::Preceding: {
      auto ptr = reinterpret_cast<const org::apache::arrow::ir::flatbuf::Preceding *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Bound::Following: {
      auto ptr = reinterpret_cast<const org::apache::arrow::ir::flatbuf::Following *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Bound::CurrentRow: {
      auto ptr = reinterpret_cast<const org::apache::arrow::ir::flatbuf::CurrentRow *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyBoundVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyBound(
        verifier,  values->Get(i), types->GetEnum<Bound>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyRexValue(flatbuffers::Verifier &verifier, const void *obj, RexValue type) {
  switch (type) {
    case RexValue::NONE: {
      return true;
    }
    case RexValue::RexLiteral: {
      auto ptr = reinterpret_cast<const org::apache::arrow::ir::flatbuf::RexLiteral *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RexValue::RexDereference: {
      auto ptr = reinterpret_cast<const org::apache::arrow::ir::flatbuf::RexDereference *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RexValue::RexFunction: {
      auto ptr = reinterpret_cast<const org::apache::arrow::ir::flatbuf::RexFunction *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RexValue::RexWindowFunction: {
      auto ptr = reinterpret_cast<const org::apache::arrow::ir::flatbuf::RexWindowFunction *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyRexValueVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyRexValue(
        verifier,  values->Get(i), types->GetEnum<RexValue>(i))) {
      return false;
    }
  }
  return true;
}

inline const org::apache::arrow::ir::flatbuf::Rex *GetRex(const void *buf) {
  return flatbuffers::GetRoot<org::apache::arrow::ir::flatbuf::Rex>(buf);
}

inline const org::apache::arrow::ir::flatbuf::Rex *GetSizePrefixedRex(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<org::apache::arrow::ir::flatbuf::Rex>(buf);
}

inline bool VerifyRexBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<org::apache::arrow::ir::flatbuf::Rex>(nullptr);
}

inline bool VerifySizePrefixedRexBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<org::apache::arrow::ir::flatbuf::Rex>(nullptr);
}

inline void FinishRexBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Rex> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedRexBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<org::apache::arrow::ir::flatbuf::Rex> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace flatbuf
}  // namespace ir
}  // namespace arrow
}  // namespace apache
}  // namespace org

#endif  // FLATBUFFERS_GENERATED_IRROWEXPRESSION_ORG_APACHE_ARROW_IR_FLATBUF_H_
